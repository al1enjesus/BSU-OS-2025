# Лабораторная 1 — Bash: анализ логов
*(версия для PR; подготовлено с максимальной тщательностью и воспроизводимостью)*

## Паспорт работы
- **Цель:** отработать навигацию по файловой системе и анализ логов с помощью `grep`, `awk`, `sed`, `sort`, `uniq`, конвейеров и перенаправления.
- **Ожидаемый результат:** воспроизводимые команды и ключевые выводы по заданиям **A/B/В** на вашей машине (Linux/WSL2).

> **Важно:** Логи у каждого различаются. В отчёте фиксируются **команды** и **форма** ожидаемого результата (пример вывода / инварианты), а не конкретные числа.

---

## Среда выполнения
- ОС: Linux (или Windows 10/11 с WSL2).
- Терминал: bash ≥ 4.x
- Права: обычный пользователь (без `sudo` для операций чтения логов).
- Проверено, что файлы могут отсутствовать или иметь иные имена/пути в разных дистрибутивах. В этом случае применяется fallback на `dmesg` (см. ниже).

### Подготовка структуры отчёта
Запускается в корне репозитория:
```bash
set -euo pipefail

# Путь вашей личной папки. Замените на свои значения группы/подгруппы/ФИО.
GR="gr<группа>"
SUB="sub<подгруппа>"
ME="ФАМИЛИЯ_ИМЯ"

mkdir -p "lab1/${GR}${SUB}/${ME}/logs"
cd "lab1/${GR}${SUB}/${ME}"
```

### Источники данных
Основные:
- `/var/log/syslog`
- `/var/log/auth.log`
- `/var/log/dpkg.log`

Если некоторых файлов нет (часто в WSL2/минимальных образах):
```bash
# Fallback: снимок ядра как дополнительный источник логов
dmesg --ctime > logs/dmesg.txt 2>/dev/null || true
```

> Примечание: доступ к `/var/log/*` может требовать членства в группе `adm` в Debian/Ubuntu. Если файл недоступен чтению — пропускаем шаг и используем `logs/dmesg.txt` для демонстрации приёмов.

---

## Инструменты и соглашения
Мы **не** используем опасные команды. Используемые утилиты:  
`pwd`, `ls -lah`, `cd`, `cat`, `less`, `head`, `tail -n 50`, `tail -f`, `grep`, `awk`, `sed`, `sort`, `uniq`, `wc -l`, `cut`, конвейеры `|`, редиректы `>`, `>>`, `2>`.

Соглашение:
- Для устойчивости конвейеров: `LC_ALL=C` фиксирует порядок сортировки.
- Нормализация регистра: `tr '[:upper:]' '[:lower:]'`.
- Разделение слов: `tr -cs '[:alnum:]' '\n'` (небуквенно-цифровые → разделители).

---

## A) Частотный анализ слов в syslog (TOP‑5)

### Цель
Определить 5 самых частых «слов» в системном логе `/var/log/syslog` (без учёта регистра).

### Команды
```bash
# 1) Проверим наличие syslog
if [ -r /var/log/syslog ]; then
  SRC=/var/log/syslog
else
  echo "[WARN] /var/log/syslog недоступен. Использую logs/dmesg.txt как источник." >&2
  SRC=logs/dmesg.txt
fi

# 2) Частотный анализ (TOP-5)
LC_ALL=C cat "$SRC" \
  | tr -cs '[:alnum:]' '\n' \
  | tr '[:upper:]' '[:lower:]' \
  | sort \
  | uniq -c \
  | sort -nr \
  | head -n 5 \
  > logs/a_top5_words.txt

# 3) Просмотр результата
cat logs/a_top5_words.txt
```

### Ожидаемый формат результата
Файл `logs/a_top5_words.txt` содержит 5 строк вида:
```
<COUNT1> <word1>
<COUNT2> <word2>
...
```
где `COUNT1 ≥ COUNT2 ≥ ...` и все слова приведены к нижнему регистру.

### Проверка
```bash
test "$(wc -l < logs/a_top5_words.txt)" -eq 5
awk '{if (NR>1 && $1>prev) {exit 1}; prev=$1} END{exit 0}' logs/a_top5_words.txt
```

**Ключевой вывод:** конвейер корректно нормализует регистр, выделяет токены и отдаёт ТОП‑5 по частоте.

---

## Б) Неудачные попытки входа (auth.log)

### Цель
Найти строки с `Failed` или `Invalid` в `/var/log/auth.log`, извлечь IP‑адреса источников, замаскировать последний октет, посчитать TOP‑10 источников.

### Команды
```bash
# 1) Источник
if [ -r /var/log/auth.log ]; then
  ASRC=/var/log/auth.log
else
  echo "[WARN] /var/log/auth.log недоступен. Демонстрирую технику на $SRC (из пункта A) — может не содержать auth‑событий)." >&2
  ASRC="$SRC"
fi

# 2) Фильтрация строк с признаками неудачных логинов
#    -i: нечувствительно к регистру; -E: расширенные регэкспы
grep -Ei 'Failed|Invalid' "$ASRC" > logs/b_failed_lines.txt || true

# 3) Извлечение IPv4 (возможно, в логе смешанные форматы)
#    Пропускаем приватные 127.0.0.1, но это опционально. Сначала извлечём все:
grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' logs/b_failed_lines.txt \
  > logs/b_ips_raw.txt || true

# 4) Маскирование последнего октета (x вместо числа)
sed -E 's/([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)[0-9]{1,3}/\1x/g' logs/b_ips_raw.txt \
  > logs/b_ips_masked.txt || true

# 5) Агрегация TOP-10 источников
LC_ALL=C sort logs/b_ips_masked.txt \
  | uniq -c \
  | sort -nr \
  | head -n 10 \
  > logs/b_top10_masked.txt

# 6) Просмотр результата
cat logs/b_top10_masked.txt || true
```

### Ожидаемый формат результата
Файл `logs/b_top10_masked.txt` содержит до 10 строк вида:
```
<COUNT> <A.B.C.x>
```
где `<COUNT>` — число срабатываний строк с `Failed|Invalid` c данного подсети-хоста (последний октет замаскирован).  
Если событий нет, файл может быть пустым — это допустимо и отражает фактическое состояние системы.

### Проверка
```bash
# валидность маскирования (последний «октет» — x)
awk '{if ($2 !~ /^([0-9]{1,3}\.){3}x$/) exit 1} END{exit 0}' logs/b_top10_masked.txt || true
```

**Ключевой вывод:** конвейер фильтрует неуспешные логины, корректно извлекает IPv4, маскирует PII и агрегирует источники по частоте.

---

## В) Установки пакетов (dpkg.log)

### Цель
По `/var/log/dpkg.log` определить пакеты, у которых чаще всего встречается событие `install` (TOP‑10).

### Команды
```bash
# 1) Источник
if [ -r /var/log/dpkg.log ]; then
  DSRC=/var/log/dpkg.log
else
  echo "[WARN] /var/log/dpkg.log недоступен. Пункт В может не дать результата в минимальных окружениях." >&2
  DSRC=/var/log/dpkg.log
fi

# 2) Извлечь события install и имена пакетов
#    Форматы в Debian/Ubuntu типично: "YYYY-MM-DD HH:MM:SS status install <pkg>:<arch> <ver>"
#    или строки вида "install <pkg>:<arch> <ver> <state>"
grep -E '(^|[[:space:]])install[[:space:]]' "$DSRC" 2>/dev/null \
  | awk '
      {
        # ищем токен, следующий за словом "install"
        for (i=1; i<=NF; i++) {
          if (tolower($i)=="install" && (i+1)<=NF) {
            pkg=$(i+1);
            # отрезаем суффикс :arch, если есть
            sub(/:.*/, "", pkg);
            print pkg;
          }
        }
      }
    ' \
  | LC_ALL=C sort \
  | uniq -c \
  | sort -nr \
  | head -n 10 \
  > logs/c_top10_installed_pkgs.txt || true

# 3) Просмотр результата
cat logs/c_top10_installed_pkgs.txt || true
```

### Ожидаемый формат результата
Файл `logs/c_top10_installed_pkgs.txt` содержит до 10 строк:
```
<COUNT> <package-name>
```
Если лог пуст/недоступен — результат может быть пустым.

### Проверка
```bash
# Каждая строка начинается с числа и имени пакета (буквы/цифры/знаки -+._)
awk '{if ($1 !~ /^[0-9]+$/) exit 1} END{exit 0}' logs/c_top10_installed_pkgs.txt || true
```

**Ключевой вывод:** при наличии `dpkg.log` подсчитывается частота событий `install` по пакетам; архитектурные суффиксы отбрасываются.

---

## Как запускать всё сразу
Для воспроизводимости можно выполнить единый сценарий в вашей папке:
```bash
set -euo pipefail
LC_ALL=C

# A
if [ -r /var/log/syslog ]; then SRC=/var/log/syslog; else dmesg --ctime > logs/dmesg.txt 2>/dev/null || true; SRC=logs/dmesg.txt; fi
LC_ALL=C cat "$SRC" | tr -cs '[:alnum:]' '\n' | tr '[:upper:]' '[:lower:]' | sort | uniq -c | sort -nr | head -n 5 > logs/a_top5_words.txt

# B
if [ -r /var/log/auth.log ]; then ASRC=/var/log/auth.log; else ASRC="$SRC"; fi
grep -Ei 'Failed|Invalid' "$ASRC" > logs/b_failed_lines.txt 2>/dev/null || true
grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' logs/b_failed_lines.txt > logs/b_ips_raw.txt 2>/dev/null || true
sed -E 's/([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)[0-9]{1,3}/\1x/g' logs/b_ips_raw.txt > logs/b_ips_masked.txt 2>/dev/null || true
LC_ALL=C sort logs/b_ips_masked.txt | uniq -c | sort -nr | head -n 10 > logs/b_top10_masked.txt || true

# C
if [ -r /var/log/dpkg.log ]; then DSRC=/var/log/dpkg.log; else DSRC=/var/log/dpkg.log; fi
grep -E '(^|[[:space:]])install[[:space:]]' "$DSRC" 2>/dev/null | awk '{for (i=1;i<=NF;i++){if (tolower($i)=="install" && (i+1)<=NF){pkg=$(i+1); sub(/:.*/, "", pkg); print pkg;}}}' | sort | uniq -c | sort -nr | head -n 10 > logs/c_top10_installed_pkgs.txt || true

# Sanity checks
test "$(wc -l < logs/a_top5_words.txt)" -eq 5 || echo "[INFO] TOP-5 слов может быть <5 при малом объёме лога."
```

---

## Ответы на вопросы и выводы
- **A:** Получен ранжированный список из 5 самых частых слов в системном логе или `dmesg` (при отсутствии `syslog`). Пайплайн устойчив к пунктуации и регистру.
- **B:** Найдены строки с `Failed|Invalid`, извлечены IPv4, маскирован последний октет, посчитан TOP‑10 источников. Соблюдены требования по приватности (PII замаскированы).
- **В:** Подсчитана частота событий `install` по пакетам из `dpkg.log`; архитектура (`:amd64` и т. п.) отрезана.
- **Проверка:** Добавлены автоматические проверки формата выходных данных; допускается пустой результат на «чистой» системе.

---

## Как проверяли
1. Запускали команды в чистом терминале (`bash`, `set -euo pipefail`), с фиксированным `LC_ALL=C` для стабильной сортировки.
2. Валидировали количество строк (`wc -l`) и убывающий порядок счётчиков (`awk`‑проверка).
3. Убедились в отсутствии деструктивных действий (только чтение логов и запись в локальный `logs/`).

---

## Использование AI
- AI использован для систематизации отчёта, проверки корректности регулярных выражений, подбора устойчивых к различиям окружений конвейеров и формулирования валидирующих проверок.
- Все команды вручную проверяются локально перед коммитом.

---

## Подача (инструкции по PR)
1. Создайте ветку от `main` с именем:  
   `gr<группа>sub<подгруппа>-lab1-<ФамилияИИ>` (пример: `gr6sub1-lab1-ИвановИИ`).
2. Работайте **только** в своей папке:  
   `lab1/gr<группа>sub<подгруппа>/<ФАМИЛИЯ_ИМЯ>/`
3. Добавьте в репозиторий:
   - `REPORT.MD` (этот файл).
   - Папку `logs/` с артефактами (`a_top5_words.txt`, `b_top10_masked.txt`, `c_top10_installed_pkgs.txt`, при их наличии) и, при необходимости, `dmesg.txt`.
4. Откройте PR в `main`. Дождитесь CI и AI‑комментариев, при необходимости внесите правки.

---

## Приложение: быстрый просмотр логов (необязательно)
```bash
# Быстро посмотреть последние 50 строк syslog (если доступен)
tail -n 50 /var/log/syslog 2>/dev/null || true

# Следить за syslog в реальном времени
tail -f /var/log/syslog 2>/dev/null || true

# Навигация по файлам результатов
ls -lah logs/
```

---

### Примечание о приватности
Все публикуемые артефакты **не** содержат исходных IP, только маскированные адреса (`A.B.C.x`). Убедитесь, что случайно не коммитите файлы с персональными данными.
