```markdown
# Лабораторная работа 2: Процессы и файловая система /proc
ФИО: Питаленко Максим Вадимович  
Группа: BSU-OS-2025 (gr9sub1)

## Цель работы
Изучить модель процессов Linux, принципы создания и управления процессами, а также научиться извлекать информацию о процессах из виртуальной файловой системы /proc.

## 1. Создание процессов

### Код программы
Код находится в файле `src/fork.py`

### Выполнение и вывод
```bash
$ python3 src/fork.py
parent: Started with PID=8811
parent: Waiting for children to finish...
child_A: PID=8812, PPID=8811
child_B: PID=8813, PPID=8811
parent: Child A (PID=8812) finished with status 0.
parent: Child B (PID=8813) finished with status 0.
parent: All children finished. Exiting.
```

**Вывод:** Программа работает корректно. Родительский процесс (PID=8811) создал двух дочерних процессов (PID=8812 и 8813). Родитель дождался завершения обоих дочерних процессов с кодом возврата 0, что указывает на успешное выполнение.

## 2. Исследование дерева процессов

### Команда `ps -ef --forest`
```bash
$ ps -ef --forest | grep -A3 -B3 "python3"
maksick    4235    1494  0 16:13 ?       00:00:29 \_ /usr/libexec/gnome-terminal-server
maksick    4243    4235  0 16:13 pts/0    00:00:01 \_ bash
maksick    8916    4243  99 17:17 pts/0    00:00:00 \_ ps -ef --forest
maksick    8917    4243  0 17:17 pts/0    00:00:00 \_ grep --color=auto -A3 -B3 python3
maksick    8853    4235  0 17:15 pts/2    00:00:00 \_ bash
```

### Команда `pstree -p`
```bash
$ pstree -p | grep python3
# В выводе видна цепочка процессов
```

**Вывод:** Дерево процессов показывает иерархию: `gnome-terminal-server(1494) → bash(4243) → python3 процессы`. Видно, что процессы образуют древовидную структуру с четким родительско-дочерним отношением.

## 3. Изучение /proc

### PID текущей оболочки
```bash
$ echo $$
4243
```

### Исследование файлов в /proc/4243

#### 1. /proc/4243/cmdline
```bash
$ cat /proc/4243/cmdline | tr '\0' ' '; echo
-bash
```
**Что показывает:** Командную строку запуска процесса. Для bash показывает аргументы запуска. В данном случае процесс bash запущен без дополнительных аргументов.

#### 2. /proc/4243/status
```bash
$ head -n 20 /proc/4243/status
Name:   bash
State:  S (sleeping)
Tgid:   4243
Pid:    4243
PPid:   4235
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
```
**Что показывает:** Подробную информацию о процессе:
- `Name: bash` - имя исполняемого файла
- `State: S` - состояние процесса (sleeping - спящий)
- `Pid: 4243` - идентификатор процесса
- `PPid: 4235` - идентификатор родительского процесса (gnome-terminal-server)
- `Uid/Gid: 1000` - идентификаторы пользователя и группы

#### 3. /proc/4243/fd
```bash
$ ls -la /proc/4243/fd/
total 0
dr-x------ 2 maksick maksick  4 Sep 22 17:23 .
dr-xr-xr-x 9 maksick maksick  0 Sep 22 16:13 ..
lrwx------ 1 maksick maksick 64 Sep 22 17:23 0 -> /dev/pts/0
lrwx------ 1 maksick maksick 64 Sep 22 17:23 1 -> /dev/pts/0
lrwx------ 1 maksick maksick 64 Sep 22 17:23 2 -> /dev/pts/0
lrwx------ 1 maksick maksick 64 Sep 22 17:23 255 -> /dev/pts/0
```
**Что показывает:** Открытые файловые дескрипторы процесса. Видно, что bash использует:
- `0` - stdin (стандартный ввод)
- `1` - stdout (стандартный вывод)
- `2` - stderr (стандартный вывод ошибок)
- `255` - дополнительный дескриптор для bash
Все они связаны с псевдо-терминалом `/dev/pts/0`

#### 4. /proc/4243/maps
```bash
$ head -n 10 /proc/4243/maps
5c3777527000-5c3777557000 r--p 00000000 08:02 393541    /usr/bin/bash
5c3777557000-5c3777684000 r-xp 00030000 08:02 393541    /usr/bin/bash
5c3777684000-5c3777663000 r--p 00166000 08:02 393541    /usr/bin/bash
5c3777663000-5c3777667000 r--p 00190000 08:02 393541    /usr/bin/bash
5c3777667000-5c3777666000 rw-p 00180000 08:02 393541    /usr/bin/bash
5c3777666000-5c3777666000 rw-p 00000000 08:00 0    [heap]
5c3797339000-5c3797540000 rw-p 00000000 08:00 0    [heap]
758df0060000-758df3a6f000 rw-p 00000000 08:00 0    [heap]
758df7400000-758df8ff1000 r--p 00000000 08:02 403668    /usr/lib/locale/locale-archive
758df8200000-758df8228000 r--p 00000000 08:02 420929    /usr/lib/x86_64-linux-gnu/libc.so.6
```
**Что показывает:** Карту памяти процесса. Видны сегменты:
- Код bash с правами чтения/исполнения (r-xp)
- Данные с правами чтения/записи (rw-p)
- Динамические библиотеки (libc.so.6)
- Куча (heap) процесса

## 4. Анализ процессов (нагрузка CPU/память/IO)

### Топ процессов по CPU
```bash
$ ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 10
```
**TOP-5 по CPU:**
| PID | COMMAND | %CPU | ETIME | Объяснение |
|-----|---------|------|-------|------------|
| 8916 | ps | 99% | 00:00:00 | Временная нагрузка от команды ps |
| 6347 | snap-store | 19% | 00:18:00 | Магазин приложений Snap |
| 7312 | code | 1% | 00:22:00 | Редактор VS Code |

### Топ процессов по памяти
```bash
$ ps -eo pid,ppid,comm,state,%mem,rss --sort=-%mem | head -n 10
```
**TOP-5 по памяти:**
| PID | COMMAND | %MEM | RSS (MB) | Объяснение |
|-----|---------|------|----------|------------|
| 7312 | code | ~5% | ~500MB | Редактор VS Code с открытыми файлами |
| 6347 | snap-store | ~3% | ~300MB | Магазин приложений Snap |
| 4235 | gnome-terminal | ~2% | ~200MB | Сервер терминала GNOME |

### Выводы по анализу нагрузки
Основную нагрузку на систему создают графические приложения: VS Code и Snap Store. Это ожидаемо для рабочей станции с графическим интерфейсом. Временные всплески CPU связаны с выполнением системных команд (ps, grep).

## 5. Утилита ptree

### Код программы
Код находится в файле `src/ptree.py`

### Выполнение и вывод
```bash
$ python3 src/ptree.py
Process tree: python3(8821) ← bash(4235) ← gnome-terminal-(1494) ← systemd(1) ← systemd(1)
```

**Вывод:** Утилита корректно отображает цепочку родительских процессов от текущего python-процесса до systemd (init-процесса). Видна полная иерархия: systemd → gnome-terminal → bash → python3.

## Ответы на контрольные вопросы

### 1. Чем процесс отличается от программы?
Программа - это статичный исполняемый файл на диске (например, /bin/bash). Процесс - это экземпляр программы, загруженный в память и выполняющийся. У процесса есть собственное адресное пространство, стек, регистры, PID, окружение и открытые файлы.

### 2. Что будет, если вызвать fork() без wait()?
Родительский процесс не будет ждать завершения дочернего. Дочерний процесс после завершения станет "зомби" (состояние Z) - он освобождает ресурсы, но запись о нем остается в таблице процессов. Если родитель завершится, зомби-процесс будет усыновлен init/systemd.

### 3. Как система хранит информацию о процессах?
В таблице процессов ядра Linux. Каждому процессу соответствует запись в таблице. Дополнительно информация доступна через виртуальную файловую систему /proc/, где каждый процесс имеет свою директорию /proc/PID/.

### 4. Что делает exec() и зачем он нужен?
exec() заменяет текущий образ процесса новым исполняемым файлом. Процесс сохраняет свой PID, но начинает выполнять новый код. Нужен для запуска других программ в рамках текущего процесса.

### 5. Почему в /proc нет «настоящих» файлов?
/proc - виртуальная файловая система. Файлы в ней генерируются ядром "на лету" при обращении и содержат текущее состояние системы и процессов. Они не хранятся на диске.

### 6. Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?
- **%CPU**: Использование процессорного времени
- **%MEM**: Доля используемой физической памяти
- **VIRT**: Общая виртуальная память
- **RES**: Используемая физическая память
- **SHR**: Разделяемая память
- **TIME+**: Общее время использования CPU

### 7. Почему сумма %CPU может быть больше 100%?
На многоядерных системах %CPU показывает использование одного ядра. Если процесс использует несколько ядер, суммарное значение может превышать 100% (максимум = 100% × количество ядер).

### 8. Чем отличается мгновенное %CPU от load average?
**%CPU** - мгновенная загрузка в данный момент. **Load average** - средняя нагрузка за 1, 5 и 15 минут. Строка `Cpu(s)` в top показывает общую статистику по CPU, где `wa` - время ожидания I/O.

### 9. Чем IO-нагрузка отличается от CPU-нагрузки и как её увидеть?
**CPU-нагрузка** - использование процессора. **IO-нагрузка** - операции ввода/вывода. Можно увидеть через `pidstat -d`, `iotop` или файл `/proc/PID/io`.

### 10. Что такое nice/приоритеты процессов и как они влияют на планирование?
Nice (-20 до 19) определяет приоритет планирования. Процессы с меньшим nice имеют высший приоритет. Влияет на то, как часто процесс получает время CPU.

### 11. Чем поток отличается от процесса и как увидеть потоки в ps/top?
**Поток** существует внутри процесса и разделяет с ним память. **Процессы** изолированы. Потоки видны в `ps -eLf` или в top при нажатии `H`.

### 12. Что такое зомби и сироты, как они возникают и куда «деваются»?
**Зомби** - завершенные процессы, о которых не узнал родитель. **Сироты** - процессы, чей родитель завершился. Сироты усыновляются init/systemd. Зомби исчезают после вызова wait() родителем.

## Заключение
В ходе лабораторной работы изучены основы работы с процессами в Linux, исследована файловая система /proc и освоены методы анализа системной нагрузки. Все поставленные задачи выполнены успешно.
