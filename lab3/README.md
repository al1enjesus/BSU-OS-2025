# Лабораторная 3 — Потоки, синхронизация и гонки данных

Практика по многопоточности в Linux: увидим гонки данных, устраним их примитивами синхронизации, реализуем bounded buffer (producer–consumer) и посмотрим, где видны потоки в `/proc` и утилитах.

## Правило выбора варианта
- Номер по списку группы нечётный — выполняйте Вариант 1.
- Номер по списку группы чётный — выполняйте Вариант 2.

Оба варианта сопоставимы по объёму. Выберите строго по правилу выше.

## ВАЖНО про samples/
- В `lab3/samples/` приведены СКЕЛЕТЫ (templates), а не готовые решения.
- Они содержат TODO‑места, которые студент обязан реализовать сам. Нельзя сдавать их без изменений.
- Разрешается копировать код в свою папку и доработать до рабочего решения.

## Цель
- Понять модель потоков (TID, Threads) и где их смотреть в системе.
- На практике воспроизвести race condition и корректно её устранить.
- Освоить базовые примитивы: `pthread_mutex_t`, `pthread_cond_t` и/или POSIX `sem_t`.
- Сопоставить корректность и производительность при разной синхронизации.

## Подготовка среды
```bash
sudo apt update && sudo apt install -y \
  build-essential make clang psmisc sysstat
```

## Структура сдачи (обязательно)
Работайте только в своей папке, как в ЛР1/ЛР2:

```
lab3/
  gr<группа>sub<подгруппа>/
    ФАМИЛИЯ_ИМЯ/
      REPORT.MD   # цель → шаги → выводы → как проверяли → ответы на вопросы
      src/        # исходники (C/Python). Для C — Makefile рядом или в корне папки студента
      Makefile    # (рекомендуется для C) цели: all, clean, run_...
      run.sh      # (по желанию) сценарий запуска
      logs/       # (по необходимости)
```

В каталоге `lab3/samples/` есть скелеты и `Makefile`, которые можно использовать как шаблон (см. TODO в коде).

---

## Вариант 1 (нечётные номера)

### A) Гонка данных и устранение (инкремент счётчика)
Реализуйте программу, где N потоков суммарно выполняют M инкрементов общего счётчика.
- Режим 1: без синхронизации — продемонстрировать расхождение `actual != expected`.
- Режим 2: c `pthread_mutex_t` — получить корректный результат, замерить время.
- (По желанию) Режим 3: атомики (`stdatomic.h`).

Проведите несколько запусков для N ∈ {1,2,4,8}, M подберите так, чтобы время было заметным, но разумным. Зафиксируйте `expected`, `actual`, время выполнения.

Подсказка: можно взять за основу `lab3/samples/thread_race.c` и вызывать так:
```bash
./thread_race 4 1000000 unsync
./thread_race 4 1000000 mutex
./thread_race 4 1000000 atomic   # опционально
```

### B) Producer–Consumer (bounded buffer, mutex+condvar)
Реализуйте фиксированную кольцевую очередь. Несколько производителей генерируют элементы, несколько потребителей их извлекают.
- Синхронизация: `pthread_mutex_t` + `pthread_cond_t` (сигналы `not_full`/`not_empty`).
- Корректно завершать потребителей (флаги завершения, `broadcast`, без busy‑wait).
- Проверка корректности: суммарное количество элементов и/или проверка суммы значений.

Подсказка: смотрите `lab3/samples/prodcons.c` и запустите, например:
```bash
./prodcons -P 2 -C 2 -N 100000 -B 64
```

### C) Где видны потоки
Покажите свои потоки в системе и кратко прокомментируйте:
```bash
ps -L -p <PID> -o pid,tid,psr,pcpu,stat,comm | head -n 20 | cat
cat /proc/<PID>/status | grep Threads
ls -l /proc/<PID>/task | head -n 10 | cat
```

---

## Вариант 2 (чётные номера)

### A) Гонка данных и устранение (mutex vs atomic)
Как в варианте 1, но сравните два корректных способа устранения гонки:
- `pthread_mutex_t`
- атомики (`stdatomic.h`, `atomic_fetch_add_explicit(..., memory_order_relaxed)`).

Замерьте время обоих подходов для одинаковых N и M. Сравните корректность и производительность.

### B) Producer–Consumer (bounded buffer, семафоры)
Реализуйте ту же задачу через POSIX семафоры `sem_t`:
- Два семафора: свободные слоты и занятые слоты, плюс `mutex` на доступ к очереди.
- Корректное завершение (без зависаний).
- Те же проверки корректности.

Разрешается выполнить через `mutex+condvar`, если с семафорами возникают трудности, но в отчёте укажите причину.

### C) Где видны потоки
То же, что в варианте 1.

---

## Что предоставить в PR
- `REPORT.MD` в своей папке с:
  - краткой целью, шагами, командами запуска, результатами и выводами;
  - результатами замеров (табличка/список: N, M, режим, время, expected vs actual);
  - скриншотами/фрагментами вывода `ps -L`, `/proc/<pid>/status`, `/proc/<pid>/task`;
  - ответами на вопросы (см. ниже).
- Исходники и `Makefile` с целями `all`, `clean`, `run_...`.

## Критерии зачёта
- Реализованы пункты A и B выбранного варианта, пункт C описан в отчёте.
- Корректная синхронизация, отсутствие busy‑wait, корректное завершение потоков (`join`).
- Есть замеры и короткая интерпретация (почему так получилось).
- Сборка без предупреждений: `-Wall -Wextra -O2 -pthread`.

## Вопросы для отчёта (обязательно)
1. Чем поток отличается от процесса? Где увидеть поток в `/proc` и `ps`?
2. Что такое race condition и почему `volatile` не решает проблему корректности?
3. Когда выбирать `mutex/condvar`, когда `semaphore`, когда атомики?
4. Почему синхронизация замедляет выполнение и как уменьшать contention?
5. Что такое ложное совместное использование (false sharing) и как его избежать?

## Подсказки / команды
Сборка скелетов:
```bash
cd lab3/samples && make
```

Запуски (после реализации TODO):
```bash
./thread_race 4 1000000 unsync   # для варианта 1
./thread_race 4 1000000 mutex
./thread_race 4 1000000 atomic   # для варианта 1/2

./prodcons -P 2 -C 2 -N 100000 -B 64
```

## Безопасность и ограничения
- Не используйте `sudo`. Не создавайте бесконечную нагрузку — ограничьте N/M и время.
- Высвобождайте ресурсы (`pthread_mutex_destroy`, `pthread_cond_destroy`/закрытие семафоров), делайте `join` всех потоков.
- На многоядерных системах суммарное `%CPU` может быть >100%.

---

В каталоге `lab3/samples/` лежат минимальные скелеты для старта. Их можно копировать в свою папку и адаптировать, реализовав помеченные TODO.


