# Лабораторная работа №2 - Процессы и файловая система /proc
Цель: понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc.
## 1) Создание процессов
Цель: написать программу на С или Python, где родитель порождает двух дочерних, каждый дочерний печатает свой PID и PID родителя, родитель корректно ждёт всех дочерних.
Шаги решения: написал программу на С, код находится в файле fork_example.c в директории src.
Проверка командой `gcc src/fork_example.c -Wall -Wextra -O2 -o fork_example && ./fork_example`
Ответ:
parent: start with PID=50497
child[0]: PID=50498, PPID=50497
child[1]: PID=50499, PPID=50497
parent: child 50498 exited with status 0
parent: child 50499 exited with status 0
parent: all children completed
Вывод: проверка выдала требуемый результат, а значит задание выполнено.
##2) Исследование дерева процессов
Цель: изучить структуру дерева процессов системы и найти свои процессы.
Шаги решения:
1)Сразу после запуска программы ввел команду `ps -ef --forest | head -n 30 | cat`.
Ответ:
UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 Sep20 ?        00:00:00 [kthreadd]
root           3       2  0 Sep20 ?        00:00:00  \_ [pool_workqueue_release]
root           4       2  0 Sep20 ?        00:00:00  \_ [kworker/R-rcu_gp]
root           5       2  0 Sep20 ?        00:00:00  \_ [kworker/R-sync_wq]
root           6       2  0 Sep20 ?        00:00:00  \_ [kworker/R-kvfree_rcu_reclaim]
root           7       2  0 Sep20 ?        00:00:00  \_ [kworker/R-slub_flushwq]
root           8       2  0 Sep20 ?        00:00:00  \_ [kworker/R-netns]
root          11       2  0 Sep20 ?        00:00:04  \_ [kworker/0:0H-kblockd]
root          12       2  0 Sep20 ?        00:00:00  \_ [kworker/u16:0-ipv6_addrconf]
root          13       2  0 Sep20 ?        00:00:00  \_ [kworker/R-mm_percpu_wq]
root          14       2  0 Sep20 ?        00:00:00  \_ [rcu_tasks_kthread]
root          15       2  0 Sep20 ?        00:00:00  \_ [rcu_tasks_rude_kthread]
root          16       2  0 Sep20 ?        00:00:00  \_ [rcu_tasks_trace_kthread]
root          17       2  0 Sep20 ?        00:00:03  \_ [ksoftirqd/0]
root          18       2  0 Sep20 ?        00:00:41  \_ [rcu_preempt]
root          19       2  0 Sep20 ?        00:00:00  \_ [rcu_exp_par_gp_kthread_worker/0]
root          20       2  0 Sep20 ?        00:00:00  \_ [rcu_exp_gp_kthread_worker]
root          21       2  0 Sep20 ?        00:00:00  \_ [migration/0]
root          22       2  0 Sep20 ?        00:00:00  \_ [idle_inject/0]
root          23       2  0 Sep20 ?        00:00:00  \_ [cpuhp/0]
root          24       2  0 Sep20 ?        00:00:00  \_ [cpuhp/1]
root          25       2  0 Sep20 ?        00:00:00  \_ [idle_inject/1]
root          26       2  0 Sep20 ?        00:00:01  \_ [migration/1]
root          27       2  0 Sep20 ?        00:00:01  \_ [ksoftirqd/1]
root          30       2  0 Sep20 ?        00:00:00  \_ [cpuhp/2]
root          31       2  0 Sep20 ?        00:00:00  \_ [idle_inject/2]
root          32       2  0 Sep20 ?        00:00:01  \_ [migration/2]
root          33       2  0 Sep20 ?        00:00:00  \_ [ksoftirqd/2]
root          35       2  0 Sep20 ?        00:00:00  \_ [kworker/2:0H-events_highpri]
2)Запустил команду `pstree -p | head -n 50 | cat`
Ответ:
systemd(1)-+-ModemManager(1213)-+-{ModemManager}(1233)
           |                    |-{ModemManager}(1234)
           |                    `-{ModemManager}(1237)
           |-NetworkManager(1163)-+-{NetworkManager}(1216)
           |                      |-{NetworkManager}(1217)
           |                      `-{NetworkManager}(1218)
           |-accounts-daemon(1106)-+-{accounts-daemon}(1152)
           |                       |-{accounts-daemon}(1153)
           |                       `-{accounts-daemon}(1159)
           |-avahi-daemon(1083)---avahi-daemon(1126)
           |-colord(1629)-+-{colord}(1636)
           |              |-{colord}(1637)
           |              `-{colord}(1639)
           |-cron(1107)
           |-cups-browsed(1333)-+-{cups-browsed}(1347)
           |                    |-{cups-browsed}(1348)
           |                    `-{cups-browsed}(1349)
           |-cupsd(1312)
           |-dbus-daemon(1084)
           |-fwupd(6845)-+-{fwupd}(6868)
           |             |-{fwupd}(6869)
           |             `-{fwupd}(6870)
           |-gdm3(1330)-+-gdm-session-wor(29973)-+-gdm-wayland-ses(30069)-+-gnome-session-b(30087)-+-{gnome-session-b}(30186)
           |            |                        |                        |                        |-{gnome-session-b}(30187)
           |            |                        |                        |                        `-{gnome-session-b}(30191)
           |            |                        |                        |-{gdm-wayland-ses}(30076)
           |            |                        |                        |-{gdm-wayland-ses}(30078)
           |            |                        |                        `-{gdm-wayland-ses}(30079)
           |            |                        |-{gdm-session-wor}(29974)
           |            |                        |-{gdm-session-wor}(29975)
           |            |                        `-{gdm-session-wor}(29976)
           |            |-{gdm3}(1334)
           |            |-{gdm3}(1335)
           |            `-{gdm3}(1336)
           |-gnome-remote-de(1088)-+-{gnome-remote-de}(1158)
           |                       |-{gnome-remote-de}(1161)
           |                       `-{gnome-remote-de}(1171)
           |-polkitd(1091)-+-{polkitd}(1179)
           |               |-{polkitd}(1180)
           |               `-{polkitd}(1185)
           |-power-profiles-(1898)-+-{power-profiles-}(1909)
           |                       |-{power-profiles-}(1910)
           |                       `-{power-profiles-}(1912)
           |-rsyslogd(1195)-+-{rsyslogd}(1226)
           |                |-{rsyslogd}(1227)
           |                `-{rsyslogd}(1228)
           |-rtkit-daemon(1404)-+-{rtkit-daemon}(1418)
           |                    `-{rtkit-daemon}(1419)
           |-snapd(27958)-+-{snapd}(27980)
           |              |-{snapd}(27981)
3)В данном результате я не нашёл свой процесс, ведь он работает за очень быстрое время. Затем решил запустить команду `ps -ef | grep fork_example`, результат которой `vboxuser   63763   60887  0 08:45 pts/0    00:00:00 grep fork_example`, что означает, что программа forc_example уже завершилась и все процессы завершились корректно. В итоге я решил добавить задержку в программу строками с кодом sleep() и использовать другие команды, чтобы увидеть только свои процессы. Ввел команду `ps -ef --forest | grep -E "(fork_example|$$|$BASHPID)" | head -n 30 | cat`
Ответ:
vboxuser   60887   60879  0 07:00 pts/0    00:00:00  |   \_ bash
vboxuser   64268   60887  0 09:08 pts/0    00:00:00  |       \_ ./fork_example
vboxuser   64269   64268  0 09:08 pts/0    00:00:00  |       |   \_ ./fork_example
vboxuser   64270   64268  0 09:08 pts/0    00:00:00  |       |   \_ ./fork_example
vboxuser   64273   60887  0 09:08 pts/0    00:00:00  |       \_ ps -ef --forest
vboxuser   64274   60887  0 09:08 pts/0    00:00:00  |       \_ grep -E (fork_example|60887|64274)
vboxuser   64275   60887  0 09:08 pts/0    00:00:00  |       \_ head -n 30
vboxuser   64276   60887  0 09:08 pts/0    00:00:00  |       \_ cat
4.Ввел команду `pstree -p | grep -E "(fork_example|$$|$BASHPID)" | head -n 50 | cat`
Ответ:
           |                |-gnome-terminal-(60879)-+-bash(60887)-+-cat(64312)
           |                |                        |             |-fork_example(64304)-+-fork_example(64305)
           |                |                        |             |                     `-fork_example(64306)
           |                |                        |             |-grep(64310)
Вывод: теперь я вижу свои процессы и могу их анализировать.
##3) Изучение /proc
Цель: изучить содержимое файловой системы /proc для анализа информации о процессах.
Шаги решения:
1)Я узнал PID текущей оболочки с помощью команды `echo $$`
Ответ: 60887.
2)После ввода команды `cat /proc/60887/cmdline | tr '\0' ' '; echo`
Ответ: bash
Вывод: данная команда показывает командную строку, которая использовалась для запуска процесса с данным PID.
3)Запустил  команду `head -n 20 /proc/60887/status`
Ответ:
Name:	bash
Umask:	0002
State:	S (sleeping)
Tgid:	60887
Ngid:	0
Pid:	60887
PPid:	60879
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	4 24 27 30 46 100 115 1000 
NStgid:	60887
NSpid:	60887
NSpgid:	60887
NSsid:	60887
Kthread:	0
VmPeak:	   10712 kB
VmSize:	   10712 kB
VmLck:	       0 kB
Вывод: это первые 20 строк файла status процесса с текущим PID. Данные строки содержат подробную информацию о состоянии процесса.
4)Запустил команду `ls -l /proc/60887/fd`
Ответ:
total 0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 07:09 0 -> /dev/pts/0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 07:09 1 -> /dev/pts/0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 07:09 2 -> /dev/pts/0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 07:09 255 -> /dev/pts/0
Вывод: видно файловые дескрипторы процесса с текущим PID.
##4) Анализ процессов(нагрузка CPU/память/IO)
Цель: проанализировать нагрузку на систему по CPU, памяти и вводу-выводу.
Шаги решения:
1)Я запустил команду `top -b -n 1 | head -n 20 | cat`
Ответ:
top - 19:36:06 up 11:49,  2 users,  load average: 0.48, 0.51, 0.49
Tasks: 242 total,   1 running, 241 sleeping,   0 stopped,   0 zombie
%Cpu(s): 11.4 us,  4.5 sy,  0.0 ni, 84.1 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st 
MiB Mem :   3402.7 total,    319.2 free,   1926.9 used,   1282.6 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1475.8 avail Mem 
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  30299 vboxuser  20   0 4898920 462992 168144 S  11.8  13.3  35:34.04 gnome-s+
  53089 vboxuser  20   0   11.1g 495088 185500 S   5.9  14.2   2:15.02 firefox
  54962 vboxuser  20   0   13424   5388   3340 R   5.9   0.2   0:00.02 top
      1 root      20   0   25284  15708  10844 S   0.0   0.5   0:11.71 systemd
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.11 kthreadd
      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_wo+
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      5 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      7 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      8 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
     11 root       0 -20       0      0      0 I   0.0   0.0   0:03.39 kworker+
     12 root      20   0       0      0      0 I   0.0   0.0   0:00.00 kworker+
Вывод:
средняя нагрузка: 0.48, 0.51, 0.49
процессы: всего 242, 1 активный, 241 спящих, 0 остановленных и зомби
CPU: 
  - Пользовательские процессы: 11.4%
  - Системные процессы: 4.5%
  - Простой: 84.1%
  - Ожидание I/O: 0.0%
Память:
  - Всего: 3402.7 MiB
  - Свободно: 319.2 MiB
  - Использовано: 1926.9 MiB
  - Кэш/буферы: 1282.6 MiB
  - Swap: не используется (0.0 MiB)
2) Запустил команду `ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat` Ответ:
 PID    PPID COMMAND         S %CPU %MEM     ELAPSED
  30299   30000 gnome-shell     R  9.7 13.2    06:05:56
  53936   53251 Isolated Web Co S  8.5  7.0       35:01
  53089   30299 firefox         S  6.4 14.2       35:05
  54285   30000 gnome-text-edit S  3.9  7.5       28:20
  53929   53251 Isolated Web Co S  1.4  6.7       35:01
  54931   30000 gnome-terminal- S  1.1  1.6       01:36
  54954       2 kworker/u17:1-e I  0.7  0.0       00:45
  54809       2 kworker/u19:0-w I  0.3  0.0       06:38
  52533       2 kworker/u18:2-e I  0.2  0.0       55:57
  54948       2 kworker/u19:3-e I  0.2  0.0       01:27
  48751       2 kworker/u19:1-e I  0.2  0.0    01:48:04
  53273   53251 Privileged Cont S  0.2  4.1       35:03
  52790       2 kworker/u20:3-e I  0.2  0.0       45:35
  54529       2 kworker/u17:5-e I  0.1  0.0       19:21
Вывод:
Топ-5 процессов по CPU:
1. gnome-shell - 9.7% CPU, PID 30299, 06:05:56
2. Isolated Web Co - 8.5% CPU, PID 53936, 35:01
3. firefox - 6.4% CPU, PID 53089, 35:05
4. gnome-text-edit - 3.9% CPU, PID 54285, 28:20
5. Isolated Web Co - 1.4% CPU, PID 53929, 35:01
3) Запустил команду `ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat`
Ответ:
   PID    PPID COMMAND         S %CPU %MEM   RSS
  53089   30299 firefox         S  6.5 14.1 494636
  30299   30000 gnome-shell     S  9.7 13.2 462864
  54285   30000 gnome-text-edit S  3.9  7.5 262600
  53936   53251 Isolated Web Co S  8.4  6.9 243744
  53929   53251 Isolated Web Co S  1.4  6.7 234000
  53273   53251 Privileged Cont S  0.2  4.1 146320
  45920   30299 mutter-x11-fram S  0.0  3.1 109092
  53465   53251 WebExtensions   S  0.0  2.7 96640
  45913   30000 gsd-xsettings   S  0.0  2.3 80680
  54363   53251 Web Content     S  0.0  1.9 68268
  54579   53251 Web Content     S  0.0  1.9 68220
  54024   53251 Web Content     S  0.0  1.9 68136
  45909   30299 Xwayland        S  0.0  1.8 64912
  48696   30299 gjs             S  0.0  1.8 63452
Вывод:
Топ-5 процессов по памяти:
1. firefox - 14.1%MEM, PID 53089, RSS 495
2. gnome-shell - 13.2% MEM, PID 30299, RSS 463
3. gnome-text-edit - 7.5% MEM, PID 54285, RSS 263
4. Isolated Web Co - 6.9% MEM, PID 53936, RSS 244
5. Isolated Web Co - 6.7% MEM, PID 53929, RSS 234
4) Запустил команду `pidstat -d | head -5`
Вывод:
Топ-5 процессов по IO:
1. gnome-shell - 15.31 rKB/s, 44.49 wKB/s
2. gnome-session-b - 0.09 rKB/s, 0.00 wKB/s
3. xdg-document-po - 0.07 rKB/s, 0.00 wKB/s
4. gsd-power - 0.03 rKB/s, 0.00 wKB/s
5. evolution-sourc - 0.01 rKB/s, 0.00 wKB/s
5) Также запускал команду `pidstat -u -r -d 1 5 | cat` и анализировал результат. Запускал команду `htop -u "$USER"` и получил ответ, который проанализировал.
Вывод к заданию: 
Нагружает систему:
1. Графическая среда GNOME, так как является тяжелой графической оболочкой, требующей много RAM
2. Браузер Firefox - основной потребитель памяти и IO, так как является современным браузером со множеством расширений
В виртуальной среде поведение процессов может отличаться от физической системы
и IO задержки могут быть выше из-за виртуализации, однако в моем случае система работает оптимально в виртуальной среде.
##5) Мини-утилита ptree
Цель: написать утилиту, печатающую цепочку родителей от текущего процесса до PID1.
Шаги решения: написал на С в файле ptree.c в директории src.
Проверка: запустил команду `gcc src/ptree.c -Wall -Wextra -O2 -o ptree && ./ptree`
Ответ:
bash(60887) <-gnome-terminal-(60879) <-systemd(30000) <-systemd(1)
Вывод: проверка выдала требуемый результат, а значит задание выполнено.
Также создал Makefile для работы с С-файлами.
##Вопросы для отчета
1) Программа - это статичный набор инструкций, а процесс - это выполняющий экземпляр программы.
2) Тогда дочерний процесс продолжит выполнение независимо от родителя, что может привести к появлению зомби-процессов, если родитель завершится раньше дочернего и не вызовет wait() для сбора его статуса завершения.
3) ОС хранят информацию о процессах в специализированных структурах данных, как блок управления процессами, который содержит все сведения о состоянии, идентификаторе, приоритете и других параметрах процесса. Эта информация хранится в оперативной памяти.
4) Подменяет текущий образ процесса новым.
5) В /proc находятся не "настоящие" файлы, а виртуальные, поскольку эта директория представляет собой виртуальную файловую систему, которая не хранится на диске. Вместо реальных данных она предоставляет доступ к информации о процессах и состоянии ядра ОС в реальном времени.
6) Поля команды top показывают информацию о процессах: %CPU — процент загрузки процессора, %MEM — процент использования оперативной памяти, VIRT — общий объем виртуальной памяти, RES — физический объем используемой памяти, SHR — объем разделяемой памяти, а TIME+ — суммарное время выполнения процесса с высокой точностью. 
7) Сумма загрузки %CPU может превышать 100%, потому что показатель используется как сумма загрузки всех ядер процессора. Значение выше 100% просто показывает, что процессор выполняет много задач одновременно, распределяя их между доступными ядрами. 
8) Мгновенный %CPU показывает сиюминутную загрузку процессора, тогда как Load Average — это среднее значение нагрузки за периоды 1, 5 и 15 минут, учитывающее как активные, так и ожидающие выполнения процессы, а также операции ввода-вывода. Строка Cpu(s) в top отображает детализированную статистику по загрузке CPU, включая процент занятости ядра, время ожидания ввода-вывода (wa), и другие метрики, используя экспоненциально взвешенное скользящее среднее значение. 
9) IO-нагрузка — это операции ввода-вывода, которые требуют времени ожидания и не используют CPU. CPU-нагрузка измеряет, сколько процессорного времени используется программами, и отображается в процентах. Для просмотра CPU-нагрузки используется команда top, для IO-нагрузки используется команда iotop или pidstat.
10) nice — это значение приоритета процесса, которое управляет распределением процессорного времени между процессами. Чем выше значение nice, тем ниже приоритет процесса и тем меньше процессорного времени ему выделяется; чем ниже значение nice, тем выше приоритет. Этот параметр влияет на планирование, позволяя пользователям и администраторам повышать или понижать приоритет задач, отдавая предпочтение более важным процессам и снижая потребление ресурсов у менее важных. 
11) Процесс — это независимая программа с собственным адресным пространством и ресурсами, а поток — это последовательность инструкций, выполняющаяся внутри процесса и совместно использующая его ресурсы и память. В ps и top потоки можно увидеть, используя опции, такие как -T или -L для ps, или включив режим показа потоков в top. 
12) Процессы-зомби и сироты — это два разных состояния процессов в ОС,где:
Зомби – это завершенный процесс, который продолжает занимать место в таблице процессов до тех пор, пока его родитель не прочитает его статус выхода. Зомби образуется, когда родительский процесс не выполняет системный вызов wait(). Устраняется, когда родительский процесс вызывает wait() и читает статус завершения дочернего процесса. 
Сирота – это процесс, чей родитель завершился до него. Возникает, когда родительский процесс завершается раньше своего дочернего процесса, который остается без родителя. Устраняется процессом init (PID 1), который становится новым родителем для всех сиротских процессов, пока они не будут уничтожены другими механизмами.
