1. Чем процесс отличается от программы?

    Программа - это статичный исполняемый файл на диске, содержащий код и данные. Процесс - это выполняющийся экземпляр программы с уникальным PID, контекстом исполнения, открытыми файлами и окружением.

2. Что будет, если вызвать fork() без wait()?

    Дочерний процесс станет "зомби" (zombie) после завершения, так как родитель не получит информацию о его статусе завершения. Зомби-процессы занимают запись в таблице процессов, но не используют ресурсы.

3. Как система хранит информацию о процессах?

    Информация хранится в виртуальной файловой системе /proc, где каждый процесс имеет свою директорию /proc/<pid> с файлами, содержащими информацию о состоянии, памяти, открытых файлах и т.д.

4. Что делает exec() и зачем он нужен?

    exec() заменяет текущий образ процесса новым исполняемым файлом, сохраняя при этом PID и другие атрибуты процесса. Это нужно для запуска других программ в контексте текущего процесса.

5. Почему в /proc нет «настоящих» файлов?

    /proc - виртуальная файловая система, которая существует только в памяти и предоставляет интерфейс для доступа к информации о ядре и процессах в виде файлов и директорий.

6. Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?

    %CPU: Процент использования CPU процессом

    %MEM: Процент использования физической памяти

    VIRT: Общий объем виртуальной памяти

    RES: Объем резидентной памяти (физически используемой)

    SHR: Объем разделяемой памяти

    TIME+: Общее время использования CPU

7. Почему сумма %CPU может быть больше 100%?

    На многоядерных системах каждый CPU ядро считается за 100%, поэтому если процесс использует несколько ядер одновременно, суммарный %CPU может превышать 100%.

8. Чем отличается мгновенное %CPU от load average?

    Мгновенное %CPU показывает текущую нагрузку в данный момент. Load average показывает среднюю нагрузку за последние 1, 5 и 15 минут, учитывая процессы в состоянии выполнения и ожидания.

9. Что означает строка Cpu(s) в top (в т.ч. wa)?

    us: user - время в пользовательском пространстве

    sy: system - время в пространстве ядра

    ni: nice - время процессов с измененным приоритетом

    id: idle - время простоя

    wa: I/O wait - время ожидания операций ввода/вывода

    hi: hardware interrupts - обработка аппаратных прерываний

    si: software interrupts - обработка программных прерываний

10. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть?

    CPU-нагрузка - использование процессорного времени. IO-нагрузка - операции чтения/записи на диск. Можно увидеть через pidstat -d, iotop или /proc/<pid>/io.

11. Что такое nice/приоритеты процессов и как они влияют на планирование?

    Nice value (-20 до 19) влияет на приоритет планирования процессов. Более низкие значения дают высший приоритет. Ядро планировщик учитывает nice value при распределении CPU времени.

12. Чем поток отличается от процесса и как увидеть потоки в ps/top?

    Процесс имеет独立的地址ное пространство, а потоки разделяют адресное пространство процесса. В ps можно увидеть потоки с опцией -L, в top нажать 'H' для показа потоков.

13. Что такое зомби и сироты, как они возникают и куда «деваются»?

    Зомби - завершенные процессы, чьи родители не вызвали wait(). Сироты - процессы, чьи родители завершились. Сироты усыновляются init процессом (PID 1), который периодически вызывает wait() для очистки зомби.

##Заключение:
    В ходе работы изучены основы работы с процессами в Linux, исследована файловая система /proc, проанализирована нагрузка на систему и написаны утилиты для работы с процессами. Полученные знания позволяют эффективно мониторить и управлять процессами в Linux-системах.
