# Отчёт по лабораторной работе №2
Процессы и файловая система /proc

## Цель работы
Изучить модель процессов в Linux, принципы их создания и управления, а также научиться извлекать информацию о процессах из виртуальной файловой системы /proc.

#1) Создание процессов
## Реализация
Программа на Python создаёт два дочерних процесса:
```
import os
import sys

print(f"parent(PID={os.getpid()})", flush=True)

pid1 = os.fork()
if pid1 == 0:
	print(f"child_A: PID={os.getpid()}, PPID={os.getppid()}", flush=True)
	sys.exit(0) 
else:
	os.waitpid(pid1, 0)

pid2 = os.fork()
if pid2 == 0:
	print(f"child_B: PID={os.getpid()}, PPID={os.getppid()}", flush=True)
	sys.exit(0)
else: 
	os.waitpid(pid2, 0)

input("Enter enter to exit...")
```
## Вывод программы
```
text
parent(PID=1234)
child_A: PID=1235, PPID=1234
child_B: PID=1236, PPID=1234
```
#2) Исследование дерева процессов
## Выполненные команды
```
ps -ef --forest | head -n 30
pstree -p | head -n 50
```
## Результаты
В результате видно, что процесс python(4590) является дочерним для bash(3346), который в свою очередь является дочерним для gnome-terminal-server(3339).

# 3) Изучение /proc
## Исследование процесса bash (PID=3346)
```
echo $$  # 3346
cat /proc/3346/cmdline | tr '\0' ' '; echo  # bash
head -n 20 /proc/3346/status
ls -l /proc/3346/fd
```
## Анализ файлов /proc
/proc/<pid>/cmdline - командная строка запуска процесса

/proc/<pid>/status - подробная информация о состоянии процесса (имя, PID, PPID, UID, GID, использование памяти)

/proc/<pid>/fd/ - симлинки на открытые файловые дескрипторы процесса

# 4) Анализ процессов (нагрузка CPU/память/IO)
## TOP-5 по CPU
```
PID    PPID COMMAND         S %CPU %MEM     ELAPSED
2600    2336 gnome-shell     S  3.5 11.8       48:28
3339    2336 gnome-terminal- S  0.5  1.7       48:19
4555    4409 gedit           S  0.2  1.8       21:37
1116       1 snapd           S  0.2  1.1       48:46
2724    2336 ibus-daemon     S  0.1  0.3       48:27
```
Анализ: Наибольшую CPU-нагрузку создаёт графическая оболочка gnome-shell, что ожидаемо для GUI-системы.

## TOP-5 по памяти
```
text
PID    PPID COMMAND         S %CPU %MEM   RSS
2600    2336 gnome-shell     S  3.5 11.8 412064
3204    2600 mutter-x11-fram S  0.0  3.1 108748
3138    2336 gsd-xsettings   S  0.0  2.3 80468
4555    4409 gedit           S  0.2  1.8 64804
3011    2600 Xwayland        S  0.0  1.8 64304
```
Анализ: Графические компоненты (gnome-shell, mutter, Xwayland) потребляют больше всего памяти, что характерно для desktop-окружения.

## TOP-5 по IO
```
TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN      IO    COMMAND
1    be/4 root        0.00 B/s    0.00 B/s ?unavailable?  init splash...
2    be/4 root        0.00 B/s    0.00 B/s ?unavailable?  [kthreadd]
3    be/4 root        0.00 B/s    0.00 B/s ?unavailable?  [pool_workqueue_release]
```
## Выводы:
Система не испытывает значительной IO-нагрузки.

Основная нагрузка приходится на графические процессы, что типично для виртуальной машины с GUI.

# 5) Мини-утилита ptree
## Реализация
```
import os
import sys

def get_process_info(pid):
    try:
        with open(f"/proc/{pid}/status", 'r') as f:
            content = f.read()
        
        info = {}
        for line in content.split('\n'):
            if line.startswith('Name:'):
                info['name'] = line.split(':', 1)[1].strip()
            elif line.startswith('PPid:'):
                info['ppid'] = int(line.split(':', 1)[1].strip())
        
        with open(f"/proc/{pid}/cmdline", 'r') as f:
            cmdline = f.read().replace('\0', ' ').strip()
            info['cmdline'] = cmdline if cmdline else info['name']
        
        return info
    except (FileNotFoundError, PermissionError, ProcessLookupError):
        return None

def print_process_chain(pid):
    current_pid = pid
    chain = []
    
    while current_pid != 0 and current_pid != 1:
        info = get_process_info(current_pid)
        if not info:
            break
        
        chain.append((current_pid, info['cmdline']))
        current_pid = info['ppid']
    
    if current_pid == 1:
        init_info = get_process_info(1)
        if init_info:
            chain.append((1, init_info['cmdline']))
    
    for i, (proc_pid, proc_cmd) in enumerate(reversed(chain)):
        if i == len(chain) - 1:
            print(f"{proc_cmd}({proc_pid})")
        else:
            print(f"{proc_cmd}({proc_pid}) ← ", end="")

def main():
    if len(sys.argv) > 1:
        try:
            target_pid = int(sys.argv[1])
        except ValueError:
            print("Ошибка: PID должен быть числом")
            sys.exit(1)
    else:
        target_pid = os.getpid()
    
    print_process_chain(target_pid)

if __name__ == "__main__":
    main()
```
## Пример вывода
Вывод немного отличен от примера, потому что пользуюсь Виртуальной машиной.

```
vboxuser@ubuntu:~/BSU-OS-2025/lab2/gr9sub1/ГАРБАР_ВИОЛЕТТА/src$ python3 ptree.py 2513
/sbin/init splash noprompt noshell automatic-ubiquity crashkernel=2G-4G:320M,4G-32G:512M,32G-64G:1024M,64G-128G:2048M,128G-:4096M(1) ← /usr/sbin/gdm3(1617) ← gdm-session-worker [pam/gdm-password](2330) ← /usr/libexec/gdm-wayland-session env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/gnome-session --session=ubuntu(2428) ← /usr/libexec/gnome-session-binary --session=ubuntu(2513)

```

# Ответы на вопросы
### 1. Чем процесс отличается от программы?
Программа — это статичный набор инструкций и данных, хранящийся на диске в виде исполняемого файла. Процесс — это динамический экземпляр выполняющейся программы: код программы, данные, состояние выполнения, ресурсы, контекст безопасности.

 Т.е. программа — это файл на диске, а процесс — это активная сущность, выполняющаяся в памяти.
### 2. Что будет, если вызвать fork() без wait()?
Если вызвать fork() без последующего wait(), то дочерний процесс после завершения станет зомби.

Зомби-процесс будет занимать запись в таблице процессов, но не потребляет других ресурсов.

Родительский процесс не получит статус завершения дочернего.
### 3. Как система хранит информацию о процессах?
Информация о процессах хранится в ядре ОС (в структуре task_struct для каждого процесса) или в виртуальной файловой системе /proc — где каждый процесс представлен директорией с именем, равным его PID:

/proc/<pid>/status — основная информация о процессе,

/proc/<pid>/cmdline — командная строка запуска,

/proc/<pid>/fd/ — открытые файловые дескрипторы,

/proc/<pid>/maps — карта памяти процесса.
### 4. Что делает exec() и зачем он нужен?
exec() — это семейство системных вызовов, которые заменяют текущий образ процесса новым образом из исполняемого файла; сохраняют PID процесса, открытые файлы и другие атрибуты; сбрасывают память процесса и загружают новую программу;

exec() нужен для запуска других программ в контексте текущего процесса, что используется в комбинации с fork() для создания новых процессов.
### 5. Почему в /proc нет «настоящих» файлов?
Потому что /proc — это виртуальная файловая система (procfs).
### 6. Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?
%CPU — процент использования процессорного времени,

%MEM — доля физической памяти, используемой процессом,

VIRT — общий объем виртуальной памяти (RAM + swap),

RES — резидентная память (физическая RAM, используемая процессом),

SHR — разделяемая память (общие библиотеки и др.),

TIME+ — общее процессорное время, использованное процессом.
### 7. Почему сумма %CPU может быть больше 100%?
Потому что каждое ядро может обеспечивать до 100% нагрузки. Тогда процесс, использующий несколько ядер, может показывать %CPU > 100%!

Например, на 4-ядерной системе максимальное значение %CPU = 400%
### 8. Чем отличается мгновенное %CPU от load average? Что означает строка Cpu(s) в top (в т.ч. wa)?
Мгновенное %CPU — текущая загрузка процессора в момент измерения

Load average — средняя нагрузка за последние 1, 5 и 15 минут

Строка Cpu(s) в top показывает распределение времени процессора:

us — пользовательские процессы,

sy — системные процессы (ядро),

ni — процессы с измененным приоритетом (nice),

id — время простоя,

wa — время ожидания I/O (важный показатель задержек диска),

hi — обработка аппаратных прерываний,

si — обработка программных прерываний,

st — время, «украденное» виртуальной машиной гипервизором.
### 9. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть (pidstat -d, iotop, /proc/<pid>/io)?
CPU-нагрузка — использование процессорного времени, а IO-нагрузка — операции ввода-вывода (диск, сеть).

pidstat -d — статистика IO по процессам,

iotop — мониторинг IO в реальном времени (требует root),

/proc/<pid>/io — информация об IO конкретного процесса.
### 10. Что такое nice/приоритеты процессов и как они влияют на планирование?
Nice — значение от -20 (высший приоритет) до 19 (низший приоритет)

Влияет на планировщик задач: процессы с higher priority (меньшее значение nice) получают больше CPU времени.

(По умолчанию процессы имеют nice = 0)
### 11. Чем поток отличается от процесса и как увидеть потоки в ps/top?
Процесс — изолированная единица выполнения с собственными ресурсами.
Поток — часть процесса, разделяющая с другими потоками память и ресурсы.

Как увидеть потоки:
ps -eLf — показать процессы с потоками (LWP — Light Weight Process),
top -H — показать потоки вместо процессов.

В top можно включить отображение потоков клавишей 'H'.
### 12. Что такое зомби и сироты, как они возникают и куда «деваются»?
Зомби (zombie) — завершенный процесс, оставшийся в таблице процессов, потому что родитель не вызвал wait(). Исчезают после завершения родителя.

Сироты (orphans) — процессы, чей родитель завершился до них. Усыновляются процессом init (PID 1), который вызывает wait() для них.

Зомби не потребляют ресурсы, но занимают записи в таблице процессов. Сироты продолжают нормальное выполнение, но с новым родителем (init).

# На начальных этапах работы было сложно понимать концепцию "процессов".
# В интернете немного сайтов с систематизированной инфформацией по теме, поэтому иногда просила объяснить какие-то понятия ИИ.

# Изучила модель процессов в Linux, принципы их создания и управления, а также научилась извлекать информацию о процессах из виртуальной файловой системы /proc.
