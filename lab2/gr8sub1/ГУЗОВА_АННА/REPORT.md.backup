# Лабораторная 2 — Процессы и файловая система

Практика по процессам Linux. В этой работе разберём, что такое процесс, как они создаются, где смотреть информацию о них в /proc, и напишем простые программы.

## Цели
- Научиться порождать и корректно дожидаться завершения дочерних процессов.
- Извлекать сведения о процессах из `/proc/<pid>/…`.
- Снимать и интерпретировать статистику нагрузки CPU/памяти/IO.
- Реализовать небольшую утилиту `ptree`.

## Среда
- ОС: Linux Debian
```
  sudo apt update && sudo apt install -y \
  build-essential psmisc sysstat
```
## Задания

### 1) Создание процессов

Родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

Шаги/решение:

- Создать программу на C, где родитель дважды вызывает `fork()` (в цикле `i=0..1`).
- В ветке ребёнка распечатать `PID` и `PPID`, сбросить буфер (`fflush(stdout)`), завершиться через `_exit(0)`.
- В родителе сохранить PIDs детей в массив.
- Последовательно вызвать `waitpid(child[i], &status, 0)`, вывести коды завершения.
- В конце родитель печатает, что всё завершено.

Команда для запуска:
```bash
make fork_example
make run_fork_example
```

Результат:
>[parent] start, PID=8854
>[child A] PID=8855, PPID=8854
>[child B] PID=8856, PPID=8854
>[parent] child 8855 exited, status=0
>[parent] child 8856 exited, status=0
>[parent] done

**Вывод:**
Родитель корректно порождает два дочерних процесса и дожидается их завершения; буферизация не «съедает» строки.

**Использование ИИ:**
Подсказки по построению `Makefile`, а также помощь в написании `fork_example.c`

### 2) Исследование дерева процессов

Шаги/решение:

- Запустить ./fork_example.
- Просмотреть дерево процессов: ps -ef --forest и/или pstree -p.
- Сопоставить PID родителя и детей с выводом программы

Команда:
```bash
ps -ef --forest | head -n 30 | cat
```

Вывод в консоль:

> UID          PID    PPID  C STIME TTY          TIME CMD
> root           2       0  0 13:28 ?        00:00:00 [kthreadd]
> root           3       2  0 13:28 ?        00:00:00  \_ [pool_workqueue_release]
> root           4       2  0 13:28 ?        00:00:00  \_ [kworker/R-kvfree_rcu_reclaim]
> root           5       2  0 13:28 ?        00:00:00  \_ [kworker/R-rcu_gp]
> root           6       2  0 13:28 ?        00:00:00  \_ [kworker/R-sync_wq]
> root           7       2  0 13:28 ?        00:00:00  \_ [kworker/R-slub_flushwq]
> root           8       2  0 13:28 ?        00:00:00  \_ [kworker/R-netns]
> root          12       2  0 13:28 ?        00:00:00  \_ [kworker/u8:0-ipv6_addrconf]
> root          13       2  0 13:28 ?        00:00:00  \_ [kworker/R-mm_percpu_wq]
> root          14       2  0 13:28 ?        00:00:00  \_ [rcu_tasks_kthread]
> root          15       2  0 13:28 ?        00:00:00  \_ [rcu_tasks_rude_kthread]
> root          16       2  0 13:28 ?        00:00:00  \_ [rcu_tasks_trace_kthread]
> root          17       2  0 13:28 ?        00:00:01  \_ [ksoftirqd/0]
> root          18       2  0 13:28 ?        00:00:04  \_ [rcu_preempt]
> root          19       2  0 13:28 ?        00:00:00  \_ [rcu_exp_par_gp_kthread_worker/0]
> root          20       2  0 13:28 ?        00:00:00  \_ [rcu_exp_gp_kthread_worker]
> root          21       2  0 13:28 ?        00:00:00  \_ [migration/0]
> root          22       2  0 13:28 ?        00:00:00  \_ [idle_inject/0]
> root          23       2  0 13:28 ?        00:00:00  \_ [cpuhp/0]
> root          24       2  0 13:28 ?        00:00:00  \_ [cpuhp/1]
> root          25       2  0 13:28 ?        00:00:00  \_ [idle_inject/1]
> root          26       2  0 13:28 ?        00:00:00  \_ [migration/1]
> root          27       2  0 13:28 ?        00:00:02  \_ [ksoftirqd/1]
> root          34       2  0 13:28 ?        00:00:00  \_ [kdevtmpfs]
> root          35       2  0 13:28 ?        00:00:00  \_ [kworker/R-inet_frag_wq]
> root          36       2  0 13:28 ?        00:00:00  \_ [kauditd]
> root          37       2  0 13:28 ?        00:00:00  \_ [khungtaskd]
> root          38       2  0 13:28 ?        00:00:00  \_ [oom_reaper]
> root          40       2  0 13:28 ?        00:00:00  \_ [kworker/R-writeback]
> 

Команда:
```bash
ps -ef --forest | head -n 30 | cat
```

Вывод в консоль:

> systemd(1)-+-ModemManager(765)-+-{ModemManager}(768)
>            |                   |-{ModemManager}(771)
>            |                   `-{ModemManager}(775)
>            |-NetworkManager(736)-+-{NetworkManager}(769)
>            |                     |-{NetworkManager}(770)
>            |                     `-{NetworkManager}(772)
>            |-accounts-daemon(652)-+-{accounts-daemon}(674)
>            |                      |-{accounts-daemon}(675)
>            |                      `-{accounts-daemon}(733)
>            |-avahi-daemon(656)---avahi-daemon(704)
>            |-colord(929)-+-{colord}(936)
>            |             |-{colord}(937)
>            |             `-{colord}(939)
>            |-cron(659)
>            |-cups-browsed(7632)-+-{cups-browsed}(7637)
>            |                    |-{cups-browsed}(7638)
>            |                    `-{cups-browsed}(7639)
>            |-cupsd(7630)
>            |-dbus-daemon(661)
>            |-gdm3(799)-+-gdm-session-wor(1336)-+-gdm-wayland-ses(1398)-+-gnome-session-b(1410)-+-{gnome-session-b}(1454)
>            |           |                       |                       |                       |-{gnome-session-b}(1455)
>            |           |                       |                       |                       |-{gnome-session-b}(1456)
>            |           |                       |                       |                       `-{gnome-session-b}(1457)
>            |           |                       |                       |-{gdm-wayland-ses}(1405)
>            |           |                       |                       |-{gdm-wayland-ses}(1406)
>            |           |                       |                       `-{gdm-wayland-ses}(1407)
>            |           |                       |-{gdm-session-wor}(1337)
>            |           |                       |-{gdm-session-wor}(1338)
>            |           |                       `-{gdm-session-wor}(1339)
>            |           |-{gdm3}(801)
>            |           |-{gdm3}(802)
>            |           `-{gdm3}(803)
>            |-low-memory-moni(666)-+-{low-memory-moni}(681)
>            |                      |-{low-memory-moni}(682)
>            |                      `-{low-memory-moni}(734)
>            |-polkitd(669)-+-{polkitd}(741)
>            |              |-{polkitd}(743)
>            |              `-{polkitd}(746)
>            |-power-profiles-(1167)-+-{power-profiles-}(1175)
>            |                       |-{power-profiles-}(1176)
>            |                       `-{power-profiles-}(1177)
>            |-rsyslogd(670)-+-{rsyslogd}(722)
>            |               |-{rsyslogd}(723)
>            |               `-{rsyslogd}(724)
>            |-rtkit-daemon(852)-+-{rtkit-daemon}(867)
>            |                   `-{rtkit-daemon}(868)
>            |-switcheroo-cont(671)-+-{switcheroo-cont}(705)
>            |                      |-{switcheroo-cont}(706)
>            |                      `-{switcheroo-cont}(735)
>            |-systemd(1345)-+-(sd-pam)(1347)

**Вывод:** С помощью этих комманд можно наглядно увидеть устройство процессов в системе. С помощью первой команды мы видим подробно каждый процесс, а с помощью второй мы видим устройство и иерархию процессов

**Использование ИИ:**
Помощь в объяснении вывода команд

### 3) Изучение /proc

Родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

Шаги/решение:

- Узнать PID текущего shell: echo $$.
- Посмотреть cmdline
- Посмотреть status (имя, состояние, PPid, UID и др.).
- Просмотреть fd/

Команды:

```
echo $$
cat /proc/$$/cmdline | tr '\0' ' '; echo
head -n 20 /proc/$$/status
ls -l /proc/$$/fd | head
```

Вывод в консоль:

> 8431
> bash 
> Name: bash
> Umask: 0002
> State: S (sleeping)
> Tgid: 8431
> Ngid: 0
> Pid: 8431
> PPid: 8423
> TracerPid: 0
> Uid: 1000 1000 1000 1000
> Gid: 1000 1000 1000 1000
> FDSize: 256
> Groups: 4 27 100 1000 
> NStgid: 8431
> NSpid: 8431
> NSpgid: 8431
> NSsid: 8431
> Kthread: 0
> VmPeak:     8972 kB
> VmSize:     8972 kB
> VmLck:        0 kB
> total 0
> lrwx------ 1 hannahuzova hannahuzova 64 Sep 21 15:58 0 -> /dev/pts/0
> lrwx------ 1 hannahuzova hannahuzova 64 Sep 21 15:58 1 -> /dev/pts/0
> lrwx------ 1 hannahuzova hannahuzova 64 Sep 21 15:58 2 -> /dev/pts/0
> lrwx------ 1 hannahuzova hannahuzova 64 Sep 21 15:58 255 -> /dev/pts/0

**Вывод:**
- `cmdline` показывает, чем и с какими аргументами запущен процесс.
- `status` даёт срез состояния и метаданные: имя, состояние сна, родителя, UID/GID, лимиты и память — всё согласовано для интерактивного шелла.
- `fd/` раскрывает открытые дескрипторы: стандартные потоки и внутренний FD bash — все направлены в твой терминал /dev/pts/0.

**Использование ИИ:**
Помощь в объяснении вывода команд

### 4) Анализ процессов (нагрузка CPU/память/IO)
Cрез: TOP-5 по CPU и памяти

Шаги/решение:
- Снять TOP по CPU:
`ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15.`
- Снять TOP по памяти: 
`ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15.`
- Замер дискового ввода/вывода «тяжёлых» процессов
`sudo iotop -b -n 5 | head -n 30 | cat` 

Команда:
```bash
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
```

ТОП-5 по CPU:

>   6480    1529 firefox-esr     S 10.2 16.1    01:05:21
>   1529    1345 gnome-shell     S  7.3 11.8    02:43:54
>   6670    6480 Isolated Web Co S  5.6  9.8    01:05:17
>   1617    1481 gnome-software  S  0.8  5.2    02:43:53
>   8938       2 kworker/u9:2-ev I  0.7  0.0       42:41
> 

**Промежуточный вывод:**
Основные процессы это браузер Firefox и графическая среда GNOME

Команда:
```bash
pidstat -u -r -d 1 5 | cat
```

ТОП-5 по памяти:

> 04:14:59 PM  1000      1529     90.00      0.00 4069680  240208  11.89  gnome-shell
> 04:14:59 PM  1000      6480      3.00      0.00 11777992  334892  16.57  firefox-esr
> 04:14:59 PM  1000      6670    525.00      0.00 11214836  203488  10.07  Isolated Web Co
> 04:14:59 PM  1000      6677      2.00      0.00 2420908   43372   2.15  Isolated Servic
> 04:14:59 PM  1000     10873      4.00      0.00    4756    3608   0.18  pidstat

**Промежуточный вывод:**
Основные процессы по памяти это браузер Firefox и графическая среда GNOME

Команда:
```bash
sudo iotop -b -n 5 | head -n 30 | cat
```

Результат вывода команды указан на скриншоте iotop_result.jpg

**Промежуточный вывод:**
В момент измерения процессы не нагружали диск вовсе

**Вывод:**
По выводу команд, приведенных выше, можно заметить, что бльше всего систему нагружали браузер firefox и графическая среда GNOME, а также, можно заметить, что дис не был нагружен вовсе. Еще стоит заметить, что так как я использовала виртуальную машину, поведение может отличаться

**Использование ИИ:**
Помощь в анализе вывода команд

### 5) Мини‑утилита ptree

Шаги/решение:

- Прочитать PPid из /proc/self/status.
- Рекурсивно подниматься по родителям: для каждого pid читать /proc/<pid>/status, извлекать Name и PPid.
- Печатать цепочку name(pid) ← name(pid) ← ... до pid == 1.

Команда для запуска:
```bash
make ptree
make run_ptree
```

Вывод команды:
systemd(1) ← systemd(1345) ← gnome-terminal-(8423) ← bash(12991) ← make(13008) ← ptree(13009)

**Вывод**
Цепочка родителей строится корректно до systemd(1). Утилита демонстрирует практическое чтение /proc.

**Использование ИИ**
Помощь в написаниии кода

### Ответы на вопросы

1) Чем процесс отличается от программы?
Программа — это статическийнабор инструкций и данных.
Процесс — это «живой» экземпляр программы в памяти, у которого есть:

- Уникальный PID и принадлежность к пользователю/группе (UID/GID);
контекст исполнения: регистры CPU, стек(и), адресное пространство (код, данные, heap, mmap), маски сигналов;
- Открытые ресурсы: файловые дескрипторы, сокеты, каналы, таймеры, mmap-ы, cgroup, namespace’ы;
- Состояние планировщика (готов, спит, зомби и т.д.) и накопленное CPU-время.

2) Что будет, если вызвать fork() без wait()?
fork() создаёт дочерний процесс. Если родитель не вызывает wait()/waitpid():

- Когда ребёнок завершится, ядро сохранит его статус завершения и учётные данные, но не сможет полностью убрать запись о нём — это зомби (defunct). Он не потребляет RAM/CPU, но занимает PID и слот в таблице процессов
- Большое число «невыжданных» детей → утечка PID’ов и слотов. В крайности новые fork() начнут падать (например, EAGAIN);
- Если родитель сам завершится раньше, «зомби» не возникнет: дети станут сиротами и будут «усыновлены» PID 1 (обычно systemd), который их впоследствии «выждет».

3) Как система хранит информацию о процессах?
В ядре Linux каждый поток/процесс представлен структурой task_struct. Через указатели она связана с:

- mm_struct (адресное пространство: код/heap/stack/mmap, vm_area_struct списки),
- files_struct (таблица файловых дескрипторов),
- signal_struct/sighand_struct (сигналы и обработчики),
- cred (UID/GID/капаibilities),
- Данными планировщика (CFS/RT, приоритеты, статистика). Отображение для user space — виртуальная FS /proc: каталоги /proc/pid с файлами cmdline, status, stat, maps, fd/, io, sched, limits, environ и т.д. Значения генерируются на лету ядром (не лежат на диске).

4) Что делает exec() и зачем он нужен?
Семейство exec*() (внутри ядра — execve) заменяет образ текущего процесса: выгружает старую программу, загружает новый ELF/скрипт, создаёт новый стек/heap/карты памяти, но PID остаётся прежним. При этом:

- Наследуются открытые FD (если не помечены FD_CLOEXEC);
- Сбиваются пользовательские обработчики сигналов (возвращаются к SIG_DFL), часть атрибутов сбрасывается;
- Задаются новые argv/envp.

5) Почему в /proc нет «настоящих» файлов?
/proc — это виртуальная файловая система. Её содержимое формируется в момент чтения из структур ядра, а не из хранилища. 

6) Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?
- %CPU — доля времени CPU, которое процесс/поток получил за интервал выборки. Для многопоточной задачи может суммироваться по ядрам (см. п.7).
- %MEM ≈ RES / RAM_total * 100% (грубо: доля резидентной памяти).
- VIRT — размер виртуального адресного пространства: код + данные + mmap (+ резерв, + библиотeки, + возможный swap). Не равно использованию RAM.
- RES — резидентная память: реально загруженные в RAM страницы (не включает выгруженные в swap).
- SHR — часть RES, потенциально разделяемая с другими (например, общие библиотеки).
- TIME+ — накопленное CPU-время процесса (user+system) с точностью до сотых секунды; для многопоточных — суммарно по всем потокам.

7) Почему сумма %CPU может быть больше 100%?
Если система многопроцессорная/многоядерная, то на 4 ядрах теоретический максимум для одного процесса (с 4 активными потоками) ≈ 400%;
для всей системы — до N×100%, где N — число логических CPU.

8) Чем отличается мгновенное %CPU от load average? Что означает строка Cpu(s) в top (в т.ч. wa)?
- %CPU — моментная доля использования CPU конкретным процессом (или системой) за интервал
- load average — среднее количества задач в состояниях runnable (готовы к выполнению)

9) Чем IO-нагрузка отличается от CPU-нагрузки и как её увидеть?
CPU-нагрузка — процесс активно выполняет инструкции → высокий %CPU, низкий wa. Диагностика: `top, ps --sort=-%cpu, pidstat -u, профайлеры.`
IO-нагрузка — процесс часто ждёт хранения/сети → низкий %CPU, высокие задержки, возможен рост wa в Cpu(s). Диагностика:
`pidstat -d/iotop//proc/<pid>/io`

10) Что такое nice/приоритеты процессов и как они влияют на планирование?
В Linux для «обычных» задач действует планировщик CFS (Completely Fair Scheduler):

nice — желательность (-20…+19). Меньше значение → выше приоритет на CPU (получает больше доли времени). Большее значение → «добрее» к соседям (получает меньше).

11) Чем поток отличается от процесса и как увидеть потоки в ps/top?
Процессы имеют отдельные адресные пространства.
Потоки (LWP в Linux) делят адресное пространство и большинство ресурсов процесса (код, данные, файлы), но у каждого — свой TID (thread ID), стек и регистры.

12) Что такое зомби и сироты, как они возникают и куда «деваются»?
Зомби — процесс завершился, но родитель ещё не вызвал wait(). 

Сироты — у процесса умер родитель. Тогда ядро меняет им родителя на PID 1, который затем вызовет wait() и уберёт их зомби-состояния.

Куда «деваются»:
- зомби исчезают сразу после wait() на их PID;
- сироты продолжают жить под systemd, а после завершения «выжидаются» им же и тоже исчезают.

## Как это проверялось
Последовательно запускалиись команды и утилиты(fork_example, ptree), после чего анализировался их вывод в консоль

## Итоги
Понимаю модель процессов Linux (fork/exec/wait), умею извлекать информацию из /proc, вижу разницу между моментными и интервальными метриками и могу объяснить, что именно «нагружает» мою систему.