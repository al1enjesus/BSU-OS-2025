Отчет о выполнении Лабораторная 2 — Процессы и файловая система /proc

Цель: Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc.

Шаг 1 - Создание процессов.
Создан программа на С, в которой процесс родитель порождает два дочерние процесса. Каждый дочерний процесс печатает: child[i]: PID=<pid>, PPID=<ppid>. Родитель печатает старт/завершение и ожидает обоих детей с выводом кода завершения. Запускаем программу с помощью команды gcc src/fork_example.c -Wall -Wextra -O2 -o fork_example && ./fork_example. Таким образом при запуске выдается 
-Wall -Wextra -O2 -o fork_example && ./fork_example
parent: PID=20978 start
child[1]: PID=20980, PPID=20978
child[0]: PID=20979, PPID=20978
parent: child PID=20979 exited, code=0
parent: child PID=20980 exited, code=0
parent: PID=20978 finished

Шаг 2 - Исследование дерева процессов
При вводе команды ps -ef --forest | head -n 30 | cat выводятся первые 30 работающих процессов в табличном виде. При вводе команды pstree -p | head -n 50 | cat выводятся первые 50 строк работающих процессов в графической форме.
Сравнив таблицы можно заметить, что они совпадают по связям, используя первую формулу можно легко смотреть PID и PPID, а во второй хорошо видна структура дерева процессов.

Шаг 3 - Изучение /proc
При вводе команды echo $$ выводится PID текущей оболочки. У меня 19592.
Команда cat /proc/19592/cmdline | tr '\0' ' '; echo показывает, с какой командной строкой был запущен процесс. У меня выводит bash.
Команда head -n 20 /proc/19592/status выводит основную информацию о процессе: имя, состояние, PID и PPID, UID и GID пользователя, использование памяти и приоритеты.
Команда ls -l /proc/19592/fd выводит содержимое каталога, содержащего символические ссылки на все открытые файловые дескрипторы процесса.

Шаг 4 - Анализ процессов (нагрузка CPU/память/IO)
Использую команду top -b -n 1 | head -n 20 | cat, которая показывает первые 20 строк отчёта top, то есть нагрузку на систему и список самых активных процессов.
Команда ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat показывает 15 самых многозатратных процессов по CPU. У меня это:
    PID    PPID COMMAND         S %CPU %MEM     ELAPSED
  34062   19592 ps              R  300  0.1       00:00
   2530    1418 firefox         S 11.7 17.9    09:53:27
   7361    2780 Isolated Web Co S  9.4 14.3    08:05:20
   1418    1146 gnome-shell     S  8.5  7.4    09:54:39
   4900    2780 Isolated Web Co S  1.8  9.9    09:27:03
   4346    2780 Isolated Web Co S  1.0  4.8    09:30:58
  34037       2 kworker/u20:2-e I  0.9  0.0       00:27
  18082    1418 gnome-text-edit S  0.8  5.8    04:49:11
   2805    2780 WebExtensions   S  0.7  6.4    09:53:24
  34007    2780 Web Content     S  0.5  1.4       00:29
  33719    2780 Isolated Servic S  0.4  1.8       07:09
   3523    2780 Isolated Web Co S  0.4  3.6    09:53:22
  33829    2780 Web Content     S  0.2  1.4       04:28
   4404    2780 Isolated Servic S  0.2  1.6    09:30:56
Команда ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat показывает 15 процессов, которые занимают больше всего оперативной памяти. У меня это 
   PID    PPID COMMAND         S %CPU %MEM   RSS
   2530    1418 firefox         S 11.7 17.9 800608
   7361    2780 Isolated Web Co S  9.4 13.5 605120
   4900    2780 Isolated Web Co S  1.8  9.9 444800
   1418    1146 gnome-shell     S  8.5  7.4 333076
  18082    1418 gnome-text-edit S  0.9  5.8 260240
   4346    2780 Isolated Web Co S  1.0  4.8 214872
   2805    2780 WebExtensions   S  0.7  4.0 180488
   3523    2780 Isolated Web Co S  0.4  3.6 160540
   2845    2780 Privileged Cont S  0.1  3.1 140288
  16850    1146 nautilus        S  0.0  2.9 129260
   4622    2780 Isolated Web Co S  0.1  2.8 125196
   4397    2780 Isolated Web Co S  0.1  1.8 80556
   4404    2780 Isolated Servic S  0.2  1.6 72092
  33829    2780 Web Content     S  0.2  1.4 66120
Команда pidstat -u -r -d 1 5 | cat позволяет наблюдать на нагрузкой на систему процессами в реально времени.
Команда htop -u "$USER" выводит информацию о процессах в визуальном формате.
Топ 5 процессов по CPU:
   PID  COMMAND         %CPU     ELAPSED
  34062 ps               300      00:00
   2530 firefox         11.9    10:25:42
   7361 Isolated Web Co  9.8    08:37:35
   1418 gnome-shell      8.8    10:26:54
   4900 Isolated Web Co  1.8    09:59:18
   ps попал в список, так как он сам выполнял замер и мгновенно показал 300%;
firefox и его процессы (Isolated Web Co) активно используют CPU, потому что работают вкладки браузера;
gnome-shell нагружает процессор, так как отвечает за графическую оболочку.
Топ 5 процессов по памяти:
   PID   COMMAND          %CPU %MEM  RSS
 2530    firefox          11.7 17.9 800608
   7361  Isolated Web Co   9.4 13.5 605120
   4900  Isolated Web Co   1.8  9.9 444800
   1418  gnome-shell       8.5  7.4 333076
  18082  gnome-text-edit   0.9  5.8 260240
  firefox и его дочерние процессы (Isolated Web Co) занимают больше всего памяти — это вкладки и процессы браузера;
gnome-shell стабильно потребляет память, так как это графическая оболочка рабочего стола;
gnome-text-edit занимает относительно меньше, но тоже попал в ТОП-5.
Таким образом наибольшую нагрузку производит firefox и его дочерние процессы, так как открыто несколько вкладок, и каждая из них потребляет достаточно много ресурсов.

Вопросы для отчёта:

    1. Чем процесс отличается от программы?
    Программа - это файл, а процесс- выполняющаяся программа.
    2. Что будет, если вызвать fork() без wait()?
    Родительский процесс породит дочерний, но не дождётся его завершения. Дочерний после завершения станет зомби до тех пор, пока родитель не вызовет wait(). Если родитель сам завершится раньше, то дети станут сиротами и их примет init/systemd.
    3. Как система хранит информацию о процессах?
    В каталоге /proc/<pid>/
    4. Что делает exec() и зачем он нужен?
    Системный вызов exec() загружает новый процесс в адресное пространство процесса, заменяя его код и данные. PID при этом сохраняется.
    5. Почему в /proc нет «настоящих» файлов?
    /proc - это виртуальная файловая система, отображающая текущее состояние, не храня её на диске.
    6. Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?
    %CPU - процент потребления ресурсов CPU процессом.
    %MEM - процент занимаемой оперативной памяти процессом.
    VIRT - объём виртуальной памяти, выделенной процессу.
    RES - объём физической памяти используемой процессом.
    SHR - объём памяти, который процесс разделяет с другими процессами.
    TIME+ - суммарное процессорное время, затраченное процессом.
    7. Почему сумма %CPU может быть больше 100%?
    На многоядерных системах сумма %CPU может быть >100% (одно ядро ≈ 100%).
8. Чем отличается мгновенное %CPU от load average? Что означает строка Cpu(s) в top (в т.ч. wa)?
    %CPU — моментальная загрузка процессора отдельным процессом.
    load average — среднее количество процессов, находившихся в очереди на выполнение или выполнявшихся за 1, 5 и 15 минут.
    9. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть (pidstat -d, iotop, /proc/<pid>/io)?
    CPU-нагрузка — использование процессорного времени.
    IO-нагрузка — затраты времени на операции чтения/записи в устройства.
    Мониторинг: pidstat -d, iotop, файлы /proc/<pid>/io.
    10. Что такое nice/приоритеты процессов и как они влияют на планирование?
    При планировании процессы с более высоким приоритетом получают больше процессорного времени.
    11. Чем поток отличается от процесса и как увидеть потоки в ps/top?
    Процесс имеет собственное адресное пространство и системные ресурсы. Поток — это единица выполнения внутри процесса, которая использует общее адресное пространство и ресурсы процесса. Потоки можно увидеть с помощью ps -eLf.
    12. Что такое зомби и сироты, как они возникают и куда «деваются»?
    Зомби — процессы, завершившиеся, но ещё не «собранные» родителем через wait().
    Сироты — процессы, чей родитель завершился; такие процессы переподчиняются init/systemd.

