# Лабораторная 2 — Процессы и файловая система /proc

Лабораторная работа для 2‑го курса: практика по процессам Linux. В этой работе разберём, что такое процесс, как они создаются, где смотреть информацию о них в `/proc`, и напишем простые программы.

## Цель
Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из `/proc`.

## Теория (коротко)
- Визуализация (кто кого порождает, где потоки):

![Визуализация дерева процессов и потоков](../docs/lab2-process-tree.svg)

- **Процесс** — выполняющийся экземпляр программы с уникальным PID, контекстом исполнения (код, данные, стек, регистры), открытыми файловыми дескрипторами и окружением.
- **Родитель/потомки**: порождение через `fork()`; ожидание завершения через `wait()`/`waitpid()`.
- **exec()** — подмена текущего образа процесса новым (загрузка другой программы в тот же PID).
- **/proc** — виртуальная FS, отражающая состояние ядра и процессов:
  - `/proc/<pid>/cmdline` — командная строка запуска;
  - `/proc/<pid>/status` — состояние, UID, PPid и др.;
  - `/proc/<pid>/fd/` — открытые дескрипторы;
  - `/proc/<pid>/maps` — карта памяти.

## Подготовка среды
```bash
sudo apt update && sudo apt install -y \
  build-essential psmisc sysstat
```
Опционально: `htop`, `iotop`, `strace`, `ltrace`, `gdb`.

## Как хранить код и что сдавать
Работа сдаётся PR‑ом в свою папку внутри `lab2/` по схеме (аналогично lab1):

```
lab2/
  gr<группа>sub<подгруппа>/
    ФАМИЛИЯ_ИМЯ/
      REPORT.MD   # обязательный отчёт: цель → шаги → выводы → ответы → проверка
      src/        # исходники (C/Python/Bash) и/или Makefile
      Makefile    # (рекомендуется для C), цели: all, clean, run_...
      run.sh      # (по желанию) сценарий запуска
```

- **C‑код** складывайте в `src/` (например, `fork_example.c`, `ptree.c`) и собирайте `Makefile`‑ом.
- **Python‑код** — в `src/` (например, `fork_example.py`, `ptree.py`).
- Логи/скриншоты — рядом с `REPORT.MD` при необходимости.


Ветка и PR — как в корневом `README.md`: личная ветка от `main`, работать только в своей папке, открыть PR в `main`.

## Ход работы

### 1) Создание процессов
Задача: родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

Что реализовать:
- Программа на C или Python, в которой процесс‑родитель вызывает порождение дважды.
- Каждый дочерний процесс печатает: `child[i]: PID=<pid>, PPID=<ppid>` (индекс `i` любой: 0/1 или A/B).
- Родитель печатает старт/завершение и ожидает обоих детей (`wait()/waitpid()` или эквивалент в Python) с выводом кода завершения.
- Обеспечьте сброс буфера вывода (C: `fflush(stdout)`, Python: `print(..., flush=True)`) чтобы строки не терялись.

Проверка (примерные команды, адаптируйте под вашу структуру):
```bash
# C
gcc src/fork_example.c -Wall -Wextra -O2 -o fork_example && ./fork_example

# Python
python3 src/fork_example.py
```

Пример ожидаемой визуализации дерева после запуска:
```
parent(PID=1234)
├─ child_A(PID=1235)
└─ child_B(PID=1236)
```

### 2) Исследование дерева процессов
```bash
ps -ef --forest | head -n 30 | cat
```
Найдите свой процесс и родителей; сравните с:
```bash
pstree -p | head -n 50 | cat
```

### 3) Изучение /proc
1) Узнайте PID текущей оболочки: `echo $$`.

2) Посмотрите:
```bash
cat /proc/<pid>/cmdline | tr '\0' ' '; echo
head -n 20 /proc/<pid>/status
ls -l /proc/<pid>/fd
```
Кратко поясните в отчёте, что показывает каждый файл.

### 4) Анализ процессов (нагрузка CPU/память/IO)
Как в Лабе 1 анализировали логи, здесь — анализируем живые процессы.

1) Снимите моментальный срез «тяжёлых» процессов по CPU и памяти:
```bash
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
```

2) Посмотрите средние показатели за интервал (CPU/Memory/IO), требуется пакет `sysstat`:
```bash
pidstat -u -r -d 1 5 | cat   # 5 интервалов по 1 сек
```

3) По желанию: замер дискового ввода/вывода «тяжёлых» процессов (требуется root):
```bash
sudo iotop -b -n 5 | head -n 30 | cat
```

4) Визуально: можно открыть `htop` и сделать скриншот топа процессов у себя:
```bash
htop -u "$USER"
```

5) В `REPORT.MD` оформите краткую «аналитику процессов»:
- TOP‑5 по CPU: `PID`, `COMMAND`, `%CPU`, `ETIME` — откуда данные и почему именно эти процессы.
- TOP‑5 по памяти: `PID`, `COMMAND`, `%MEM`, `RSS (MiB)`.
- (Опционально) TOP‑5 по IO: `rKB/s`, `wKB/s` (или `/proc/<pid>/io`).
- Короткие выводы: что «нагружает систему» именно у вас и почему.

Примечания:
- На многоядерных системах сумма `%CPU` может быть >100% (одно ядро ≈ 100%).
- В WSL2/виртуалках поведение может отличаться; отметьте это в отчёте.

### 5) Мини‑утилита ptree (*)
Напишите утилиту, печатающую цепочку родителей от текущего процесса до PID 1 (init/systemd). Подсказка: читайте `PPid:` из `/proc/<pid>/status`.

Визуализация ожидаемого вывода:
```
bash(2345) ← gnome-terminal-server(1900) ← systemd(1)
```

## Вопросы для отчёта (обязательно)
1. Чем процесс отличается от программы?
2. Что будет, если вызвать `fork()` без `wait()`?
3. Как система хранит информацию о процессах?
4. Что делает `exec()` и зачем он нужен?
5. Почему в `/proc` нет «настоящих» файлов?
6. Как интерпретировать поля `top`: `%CPU`, `%MEM`, `VIRT`, `RES`, `SHR`, `TIME+`?
7. Почему сумма `%CPU` может быть больше 100%?
8. Чем отличается мгновенное `%CPU` от `load average`? Что означает строка `Cpu(s)` в `top` (в т.ч. `wa`)?
9. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть (`pidstat -d`, `iotop`, `/proc/<pid>/io`)?
10. Что такое `nice`/приоритеты процессов и как они влияют на планирование?
11. Чем поток отличается от процесса и как увидеть потоки в `ps`/`top`?
12. Что такое зомби и сироты, как они возникают и куда «деваются»?

## Критерии зачёта
- Есть программа с `fork()` и корректным `wait()`/`waitpid()` (или эквивалент на Python с ожиданием дочерних).
- В `REPORT.MD` приведены команды и вывод `ps`/`pstree` и содержимое файлов в `/proc` с пояснениями.
- Оформлена аналитика процессов: TOP‑5 по CPU/памяти (и, при наличии, по IO) с командами, данными и интерпретацией.
- Даны ответы на вопросы.
- (*) Реализована утилита `ptree`.

## Диагностика и советы
- Если вывод перемешивается, добавляйте `fflush(stdout)` (C) или `flush=True` в `print` (Python).
- Для отладки форков полезны `strace -f ./prog` и `ps -ef --forest`.
- На WSL2 часть файлов в `/proc`/логов может отличаться; отмечайте это в отчёте.


