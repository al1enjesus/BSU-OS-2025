Отчет по лабораторной работе №2

Задание 1) Создание процессов

Вывод написанной программы на С: 

parent: PID=16639, starting
child_A: PID=16640, PPID=16639
child_B: PID=16641, PPID=16639
parent: child_A (PID=16640) exited with status 0
parent: chuld_B (PID=16641) exited with status 0
parent: PID=16639, all children completed

Код соотвествует требованиям задания, а именно: 

- Родитель создает двух дочерних объектов
- Каждый дочерний процесс выводит свой PID и PPID
- Родитель корректно ожидает завершения всех дочерних процессов 
- Использует сброс буфера вывода (fflush/stdout)
- Выводится информация о кодах завершения дочерних процессов

Задание 2) Запуск программы

Аналитика и интерпретация результатов:

Структура дерева: 

Есть корневой процесс system(1) - процесс инициализацию результатов (PID 1)

- Все пользовательские процессы являются потоками systemd 
- Ядерные потоки (kthreadd) имеют PID 2 и являются прямыми потоками ядра (PPID 0)

Ключевые наблюдения: 

1. Ядерные процессы (Kernel Threads)
kthreadd (PID 2) - родитель всех ядерных потоков
kworker/ - рабочие потоки ядра для обработки фоновых задач
rcu_ - Read-Copy-Update механизмы для синхронизации
migration/ - балансировка нагрузки между CPU ядрами
ksoftirqd/ - обработка программных прерываний

2. Системные демоны
NetworkManager (1307) - управление сетевыми подключениями
ModemManager (1487) - управление модемами
accounts-daemon (1252) - управление учетными записями
cupsd (1588) - система печати
bluetoothd (1169) - управление Bluetooth

3. Графическая подсистема
gdm3 (1736) - менеджер дисплеев GNOME
Иерархия: gdm3 → gdm-session-wor → gdm-wayland-ses → gnome-session-b
Видны потоки графической сессии в фигурных скобках {}

4. Особенности отображения
ps --forest: показывает древовидную структуру с отступами
pstree: более наглядное представление с символами связи
Процессы в [] - ядерные потоки
Процессы в {} - потоки (threads) родительского процесса

Задание 3) Изучение /proc 

Выполненные команды: 

1. Определение PID текущей оболочки - echo $$. Вывод: 4088
2. Определение названия исполняемого файла оболочки: cat /proc/<pid>/cmdline | tr '\0' ' '; echo. Вывод: zsh 
3. Файл содержащий подробную информацию о состоянии процесса: head -n 20 /proc/4088/status 
  Ключевые поля:
  - Name: Имя процесса (zsh)
  - State: Состояние процесса (S - sleeping, R - running, etc.)
  - Pid: Идентификатор процесса (4088)
  - PPid: Идентификатор родительского процесса
  - Uid/Gid: Идентификаторы пользователя и группы
  - FDSize: Количество файловых дескрипторов
4. Файл содержащий символические ссылки на все открытые файловые дескрипторы процесса - ls -l /proc/<pid>/fd

Задание 4) Анализ процессов

Выполненные команды: 
1. Статистический снимок системы на момент выволнения: top -b -n 1 | head -n 20 | cat
2. Вывод ТОП-5 процессов по CPU: ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15
  Вывод: 
  
  PID    PPID COMMAND         S %CPU %MEM     ELAPSED
  17410    4088 ps              R  200  0.0       00:00
   8340    3677 chrome          S 14.5  5.5    03:20:02
   3773    3674 chrome          S 13.5  2.9    03:44:37
   1934    1750 gnome-shell     R  7.9  5.4    03:45:59
   3657    1934 chrome          S  4.3  4.6    03:44:39
   3688    1934 Xwayland        S  2.1  1.6    03:44:39
  15277    1934 gnome-text-edit S  1.8  2.3    01:05:35
   3778    3657 chrome          S  1.5  2.3    03:44:37
   8990    1934 telegram-deskto S  1.0  8.2    03:04:20
   3946    3677 chrome          S  0.6  3.4    03:44:24
   3969    3657 chrome          S  0.6  1.6    03:44:18
    755       2 irq/70-rtw88_pc S  0.5  0.0    03:46:16
   1765    1750 pipewire-pulse  S  0.4  0.3    03:46:00
   1760    1750 pipewire        S  0.3  0.2    03:46:00
   
3. Вывод ТОП-5 процессов по памяти: ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15
  Вывол: 
      PID    PPID COMMAND         S %CPU %MEM   RSS
   8990    1934 telegram-deskto S  0.9  8.2 657796
   8340    3677 chrome          S 14.4  5.5 436416
   1934    1750 gnome-shell     S  7.9  5.4 430212
   3657    1934 chrome          S  4.3  4.6 365684
   3946    3677 chrome          S  0.6  3.4 270460
   3773    3674 chrome          S 13.3  2.9 233868
  12013    1750 nautilus        S  0.0  2.4 194876
  15277    1934 gnome-text-edit S  1.9  2.4 192568
   3858    3677 chrome          S  0.2  2.4 190388
   3778    3657 chrome          S  1.5  2.3 184620
   3969    3657 chrome          S  0.6  1.6 132120
   3688    1934 Xwayland        S  2.1  1.6 127172
   2192    1899 evolution-alarm S  0.0  1.3 109204
   8086    8051 steamwebhelper  S  0.0  1.3 108408

4.Динамический мониторинг pidstat -u -r -d 1 5 | cat

Задание 5) Мини утилита
Вывод: ptree(15229) ← zsh(4088) ← gnome-terminal-(4079) ← systemd(1750) ← init(1)

Ответы на вопросы:

1. Чем процесс отличается от программы?
Программа - статический исполняемый файл на диске. Процесс - экземпляр выполняющейся программы с собственным адресным пространством, ресурсами и состоянием выполнения.

2. Что будет, если вызвать fork() без wait()?
Дочерний процесс станет "зомби" - он завершится, но запись о нем останется в таблице процессов до тех пор, пока родитель не вызовет wait(). Это приводит к утечке ресурсов ядра.

3. Как система хранит информацию о процессах?
В виртуальной файловой системе /proc, где каждый процесс имеет свою директорию (/proc/PID/) с файлами, содержащими информацию о состоянии, памяти, файловых дескрипторах и других характеристиках.

4. Что делает exec() и зачем он нужен?
exec() заменяет текущий образ процесса новым исполняемым файлом, сохраняя при этом PID и некоторые атрибуты. Используется для запуска новых программ внутри существующего процесса.

5. Почему в /proc нет «настоящих» файлов?
/proc - виртуальная файловая система, файлы генерируются ядром на лету при обращении к ним. Они не хранятся на диске, а представляют собой интерфейс для получения информации о системе и процессах.

6. Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?
%CPU: Использование процессорного времени

%MEM: Доля физической памяти

VIRT: Вся виртуальная память (RAM + swap)

RES: Резидентная память (физическая RAM)

SHR: Разделяемая память (библиотеки и т.д.)

TIME+: Общее время CPU использования

7. Почему сумма %CPU может быть больше 100%?
На многоядерных системах каждый процесс может использовать до 100% одного ядра. Если система имеет 4 ядра, суммарное использование может достигать 400%.

8. Чем отличается мгновенное %CPU от load average?
Мгновенное %CPU показывает текущее использование процессора. Load average - среднее количество процессов в очереди на выполнение за 1, 5 и 15 минут.

9. Что означает строка Cpu(s) в top (в т.ч. wa)?
us: user - процессы пользователя

sy: system - системные процессы

ni: nice - процессы с измененным приоритетом

id: idle - простой

wa: I/O wait - ожидание завершения операций ввода-вывода

hi/si: аппаратные/программные прерывания

st: stolen - время, "украденное" виртуальной машиной

10. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть?
CPU-нагрузка связана с вычислениями, IO-нагрузка - с операциями ввода-вывода. Мониторинг: pidstat -d, iotop, /proc/PID/io.

11. Что такое nice/приоритеты процессов и как они влияют на планирование?
Nice value (-20 до 19) влияет на приоритет планировщика. Более низкие значения дают более высокий приоритет. Влияет на распределение времени CPU между процессами.

12. Чем поток отличается от процесса и как увидеть потоки в ps/top?
Потоки разделяют адресное пространство процесса, но имеют собственные стеки и регистры. В ps показываются с ключом -L, в top - клавишей H. В pstree отображаются в {}.

13. Что такое зомби и сироты, как они возникают и куда «деваются»?
Зомби: Завершенные процессы, ожидающие вызова wait() родителем
Сироты: Процессы, чей родитель завершился (усыновляются init)
Зомби исчезают после вызова wait(), сироты завершаются нормально.
