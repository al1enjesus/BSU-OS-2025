# Лабораторная работа 2. Процессы и файловая система /proc

**Выполнил:** Филипчик Дмитрий, группа 8, подгруппа 1

## Цель работы
Изучить модель процессов в Linux, механизмы их создания и управления, а также научиться извлекать информацию о процессах из виртуальной файловой системы /proc.

## Ход работы

### Задание 1: Создание процессов
**Цель:** Написать программу, создающую два дочерних процесса.

**Код:** `src/fork_example.c`
**Компиляция:** `make fork_example`
**Запуск:** `./fork_example`

**Вывод программы:**
parent: started with PID=6600
child_A: my PID=6601, parent PID=6600
child_B: my PID=6602, parent PID=6600
parent: all children finished, exiting

**Вывод:** Программа корректно создает два дочерних процесса и ожидает их завершения с помощью `waitpid()`.

### Задание 2: Исследование дерева процессов
**Команда:** `ps -ef --forest | head -n 30 | cat`
**Вывод:** UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 14:59 ?        00:00:00 [kthreadd]
root           3       2  0 14:59 ?        00:00:00  \_ [pool_workqueue_release]
root           4       2  0 14:59 ?        00:00:00  \_ [kworker/R-rcu_gp]
root           5       2  0 14:59 ?        00:00:00  \_ [kworker/R-sync_wq]
root           6       2  0 14:59 ?        00:00:00  \_ [kworker/R-kvfree_rcu_reclaim]
root           7       2  0 14:59 ?        00:00:00  \_ [kworker/R-slub_flushwq]
root           8       2  0 14:59 ?        00:00:00  \_ [kworker/R-netns]
root          11       2  0 14:59 ?        00:00:00  \_ [kworker/0:0H-kblockd]
root          13       2  0 14:59 ?        00:00:00  \_ [kworker/R-mm_percpu_wq]
root          14       2  0 14:59 ?        00:00:00  \_ [rcu_tasks_kthread]
root          15       2  0 14:59 ?        00:00:00  \_ [rcu_tasks_rude_kthread]
root          16       2  0 14:59 ?        00:00:00  \_ [rcu_tasks_trace_kthread]
root          17       2  0 14:59 ?        00:00:00  \_ [ksoftirqd/0]
root          18       2  0 14:59 ?        00:00:06  \_ [rcu_preempt]
root          19       2  0 14:59 ?        00:00:00  \_ [rcu_exp_par_gp_kthread_worker/0]
root          20       2  0 14:59 ?        00:00:00  \_ [rcu_exp_gp_kthread_worker]
root          21       2  0 14:59 ?        00:00:00  \_ [migration/0]
root          22       2  0 14:59 ?        00:00:00  \_ [idle_inject/0]
root          23       2  0 14:59 ?        00:00:00  \_ [cpuhp/0]
root          24       2  0 14:59 ?        00:00:00  \_ [cpuhp/1]
root          25       2  0 14:59 ?        00:00:00  \_ [idle_inject/1]
root          26       2  0 14:59 ?        00:00:00  \_ [migration/1]
root          27       2  0 14:59 ?        00:00:06  \_ [ksoftirqd/1]
root          30       2  0 14:59 ?        00:00:00  \_ [cpuhp/2]
root          31       2  0 14:59 ?        00:00:00  \_ [idle_inject/2]
root          32       2  0 14:59 ?        00:00:00  \_ [migration/2]
root          33       2  0 14:59 ?        00:00:00  \_ [ksoftirqd/2]
root          34       2  0 14:59 ?        00:00:01  \_ [kworker/2:0-events]
root          36       2  0 14:59 ?        00:00:00  \_ [cpuhp/3]

**Анализ:** Команда показала системные процессы ядра, но не отобразила пользовательские процессы. kthreadd (PID 2) - родитель всех kernel threads.

**Команда:** `pstree -p | head -n 50 | cat`
**Анализ:** Команда показала пользовательское пространство процессов. Видна четкая иерархия:
Корневой процесс: systemd(1) - init-процесс (родитель всех пользовательских процессов)
Основные ветви:
    ModemManager - управление модемами
    NetworkManager - управление сетью
    accounts-daemon - управление учетными записями
    avahi-daemon - сервис zeroconf
    colord - управление цветами
    gdm3 → gnome-session - графическая сессия GNOME
    cups - сервис печати
    И другие системные демоны

### Задание 3: Изучение /proc
**PID текущей оболочки:**6589

**Команда:** `cat /proc/5678/cmdline | tr '\0' ' '; echo`
**Вывод:** `bash`
**Пояснение:** В файле хранится командная строка запуска процесса.

**Команда:** `head -n 20 /proc/5678/status`
**Вывод:** Name:	bash
Umask:	0002
State:	S (sleeping)
Tgid:	6589
Ngid:	0
Pid:	6589
PPid:	6039
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	4 24 27 30 46 100 114 1000 
NStgid:	6589
NSpid:	6589
NSpgid:	6589
NSsid:	6589
Kthread:	0
VmPeak:	   19932 kB
VmSize:	   19932 kB
VmLck:	       0 kB
**Пояснение:** Файл содержит детальную информацию о процессе:
    Name: bash - имя исполняемого файла
    State: S (sleeping) - процесс находится в состоянии ожидания
    Pid: 6589 - идентификатор процесса
    PPid: 6039 - идентификатор родительского процесса (важно для построения дерева)
    Uid: 1000 - процесс запущен от пользователя dima
    и т.д.

**Команда:** `ls -l /proc/5678/fd`
**Вывод:**
lrwx------ 1 dima dima 64 сен 21 16:44 0 -> /dev/pts/1
lrwx------ 1 dima dima 64 сен 21 16:44 1 -> /dev/pts/1
lrwx------ 1 dima dima 64 сен 21 16:44 2 -> /dev/pts/1
lrwx------ 1 dima dima 64 сен 21 16:44 255 -> /dev/pts/1
**Пояснение:** В директории находятся символические ссылки на файлы, открытые процессом:
    0 - стандартный ввод (stdin)
    1 - стандартный вывод (stdout)
    2 - стандартный вывод ошибок (stderr)
    255 - дополнительный дескриптор, используемый bash
    Все дескрипторы связаны с псевдо-терминалом /dev/pts/1	

### Задание 4: Анализ процессов

#### 1. Общая информация о системе
**Команда:** `top -b -n 1 | head -n 20 | cat`
**Вывод:** top - 17:15:15 up  2:15,  1 user,  load average: 0,93, 0,66, 0,39
Задачи: 251 total,   1 running, 250 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1,8 us,  1,8 sy,  0,0 ni, 96,5 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st 
МиБ Mem :   5810,5 total,    431,6 free,   2463,6 used,   2750,6 buff/cache     
МиБ Swap:   4096,0 total,   4096,0 free,      0,0 used.   3346,9 avail Mem 
**Анализ:** Система работает 2 часа 15 минут, загрузка CPU низкая (96.5% idle), используется 2.4GB из 5.8GB памяти.

#### 2. TOP процессов по CPU
**Команда:** `ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat`
**Вывод:**
   PID    PPID  COMMAND         S %CPU %MEM     ELAPSED
   2241    2011 gnome-shell     S 17.8 11.9    02:12:11
   3066    2241 firefox         S  9.2 14.5    02:11:22
   4086    3239 Isolated Web Co S  2.5  6.9    02:11:10
   3827    3239 Isolated Web Co S  1.5  4.7    02:11:16
   7290       2 kworker/u21:2-e I  0.9  0.0       16:42

#### 3. TOP процессов по памяти      
**Команда:** `ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat`
**Вывод:**
   PID    PPID COMMAND         S %CPU %MEM   RSS
   3066    2241 firefox         S  9.2 14.7 877912
   2241    2011 gnome-shell     S 17.8 12.0 714096
   4086    3239 Isolated Web Co S  2.5  7.0 416580
   3827    3239 Isolated Web Co S  1.5  4.7 284040
   3822    3239 Isolated Web Co S  0.3  4.2 252668

#### 4. Анализ IO нагрузки
Из вывода pidstat видно, что процессы не создают дисковой нагрузки
**Вывод:**
Среднее:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Среднее:     0       585    0,00    0,20    0,00    0,00    0,20     -  kworker/u21:3-events_unbound
Среднее:  1000      2241    2,58    2,98    0,00    0,00    5,57     -  gnome-shell
Среднее:  1000      3066    0,00    0,40    0,00    0,20    0,40     -  firefox
Среднее:  1000      4086    0,00    0,20    0,00    0,00    0,20     -  Isolated Web Co
Среднее:  1000      5886    0,00    0,20    0,00    0,00    0,20     -  Web Content
Среднее:  1000      6039    0,40    0,20    0,00    0,20    0,60     -  gnome-terminal-
Среднее:  1000      7652    0,20    0,40    0,00    0,00    0,60     -  pidstat

Среднее:   UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
Среднее:  1000      2241    441,55     62,62 5302638  713978  12,00  gnome-shell
Среднее:  1000      3066      0,40      0,00 12357964  886436  14,90  firefox
Среднее:  1000      3270      1,79      0,00 2522580  168980   2,84  Privileged Cont
Среднее:  1000      6039      0,20      0,00  582728   72056   1,21  gnome-terminal-
Среднее:  1000      7652      0,80      0,00   19172    4496   0,08  pidstat

Среднее:   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command

#### Общий вывод
 Система не испытывает дисковой нагрузки. Наибольшую нагрузку создают графическая оболочка GNOME и браузер Firefox.
 Множество процессов "Isolated Web Co" указывают на архитектуру современного Firefox с изолированными процессами для каждой вкладки/расширения,
 что улучшает безопасность и стабильность. 

### Задание 5: Утилита ptree
**Код:** `src/ptree.c`
**Компиляция:** `make ptree`
**Запуск:** `./ptree`
**Вывод:** ptree(8864) ~ make(8863) ~ bash(6589) ~ gnome-terminal-(6039) ~ systemd(2011) systemd(1)

## Ответы на вопросы

1. **Чем процесс отличается от программы?**  
   Программа — это исполняемый файл на диске (код + данные). Процесс — это экземпляр программы, загруженный в память и выполняющийся в системе.
 У процесса есть контекст выполнения: значения регистров, стек, открытые файлы и т.д.

2. **Что будет, если вызвать fork() без wait()?**  
   Родительский процесс завершится, не дождавшись потомков. Дочерние процессы станут "сиротами" и будут унаследованы процессом init (PID=1),
 который выполнит за них wait() и корректно уберет их из таблицы процессов.

3. **Как система хранит информацию о процессах?**  
   Информация о процессах хранится в виртуальной файловой системе /proc. Каждый процесс имеет свою директорию /proc/PID/ с файлами, содержащими информацию о состоянии,
 памяти, открытых файлах и т.д.

4. **Что делает exec() и зачем он нужен?**  
   Функция exec() заменяет текущий образ процесса новым исполняемым файлом. Она нужна для запуска новых программ в рамках существующего процесса.

5. **Почему в /proc нет «настоящих» файлов?**  
   /proc — виртуальная файловая система, которая существует только в памяти и предоставляет интерфейс для доступа к данным ядра и процессов в виде файлов.

6. **Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME?**  
   - %CPU: использование процессорного времени
   - %MEM: использование физической памяти
   - VIRT: общий объем виртуальной памяти
   - RES: резидентный размер (физическая память)
   - SHR: разделяемая память
   - TIME: общее процессорное время

7. **Почему сумма %CPU может быть больше 100%?**  
   На многоядерных системах каждое ядро дает 100%, поэтому если процесс использует несколько ядер, его %CPU может превышать 100%.

8. **Чем отличается мгновенное %CPU от load average?**  
   %CPU показывает мгновенную загрузку процессора, а load average — среднюю загрузку системы за 1, 5 и 15 минут.

9. **Чем IO-нагрузка отличается от CPU-нагрузки и как её увидеть?**  
   IO-нагрузка связана с операциями ввода-вывода, а CPU-нагрузка — с вычислениями. Для мониторинга IO используются: `pidstat -d`, `iotop`, `/proc/PID/io`.

10. **Что такое nice/приоритеты процессов и как они влияют на планирование?**  
   Nice value (-20 до 19) влияет на приоритет планирования. Более низкие значения дают higher priority (больше процессорного времени).

11. **Чем поток отличается от процесса и как увидеть потоки в ps/top?**  
   Потоки разделяют память и ресурсы процесса, а процессы изолированы. В `ps` потоки видны с ключом `-L`, в `top` — клавишей 'H'.

12. **Что такое зомби и сироты, как они возникают и куда «деваются»?**  
   Зомби — завершенные процессы, оставшиеся в таблице процессов до вызова wait() родителем. Сироты — процессы, чей родитель завершился; их усыновляет init.
 Зомби исчезают после вызова wait(), сироты завершаются нормально.

## Использование ИИ
*   Для исправления ошибок компиляци
*   Для объяснения команд
*   Для проверки корректности ответов на теоретические вопросы
