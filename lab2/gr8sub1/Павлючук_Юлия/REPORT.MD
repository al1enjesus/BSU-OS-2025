# Лабораторная 2 — Процессы и файловая система /proc

 В этой работе разберём, что такое процесс, как они
создаются, где смотреть информацию о них в `/proc`, и напишем простые программы.

## Цель

Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из
`/proc`.

## Ход работы

### 1) Создание процессов

Задача: родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

Что реализовать:

- Программа на Python, в которой процесс‑родитель вызывает порождение дважды.
- Каждый дочерний процесс печатает: `child[i]: PID=<pid>, PPID=<ppid>` (индекс `i` любой: 0/1 или A/B).
- Родитель печатает старт/завершение и ожидает обоих детей (`wait()/waitpid()` или эквивалент в Python) с выводом кода
  завершения.
  Реализуем такую программу на Python, исходный код лежит в `src/fork_example.py`.
  
  Для запуска воспользуемся командой:
```bash
  python3 fork_example.py
```
Вывод:
```
Parent start: PID=17195
child_0: PID=17196, PPID=17195
child_1: PID=17197, PPID=17195
Parent: child 17196 exited with code 10
Parent: child 17197 exited with code 11
Parent finish: PID=17195
```
#### Анализ
Запустился родитель с `PID=17195`, он породил двух потомков, у обоих верный родитель. Далее завершились дети с кодами
`10` и `11`они были заданы намеренно для различия, родитель дождался их и напечатал коды завершения.

### 2) Исследование дерева процессов
Запускаем программу:
```bash
python3 fork_example.py
```
У нас есть 10 секунд пока дети завершаться, поэтому видим непоный вывод:
```
Parent start: PID=20618
child_0: PID=20619, PPID=20618
child_1: PID=20620, PPID=20618
```
Вводим команду:
```bash
ps -ef --forest | grep python3

```
Я изменила команду так как изначальная показывает первые 30 строк дерева процессов.
Но в начале списка (PID=2,3,...) находятся ядровые и системные процессы, а мой python3 fork_example.py — пользовательский, он появляется намного ниже.
Поэтому в выводе я видела только [kthreadd], [kworker] и т. д., а своего процесса не видела.

Ищем процессы:
```
yuzefita   20321    2758  0 19:44 pts/0    00:00:00  |   |   \_ python3 fork_example.py
yuzefita   20322   20321  0 19:44 pts/0    00:00:00  |   |       \_ python3 fork_example.py
yuzefita   20323   20321  0 19:44 pts/0    00:00:00  |   |       \_ python3 fork_example.py
```
Далее посмотрим на процессы в виде дерева, с помощью команды

```bash
pstree -p | cat
```
Далее посмотрим на процессы в виде дерева, с помощью команды

```bash
pstree -ap | grep -A 3 -B 3 fork_example

```

И там аналогично найдём наши процессы:

```
  |   |       `-{gnome-terminal.},2750
  |   |-gnome-terminal-,2751
  |   |   |-bash,2758
  |   |   |   `-python3,22689 fork_example.py
  |   |   |       |-python3,22690 fork_example.py
  |   |   |       `-python3,22691 fork_example.py
  |   |   |-bash,19899
  |   |   |   |-grep,22702 --color=auto -A 3 -B 3 fork_example
  |   |   |   `-pstree,22701 -ap
  |   |   |-{gnome-terminal-},2752
  |   |   |-{gnome-terminal-},2753
  |   |   |-{gnome-terminal-},2755
  |   |   |-{gnome-terminal-},2756
  |   |   `-{gnome-terminal-},2757
  |   |-gnome-text-edit,13927 /home/yuzefita/fork_example.py
  |   |   |-{gnome-text-edit},13929
  |   |   |-{gnome-text-edit},13930
  |   |   |-{gnome-text-edit},13931

```

#### Использование ИИ
Помощь в изменении команд 

#### Анализ
На примерах мы видим наглядно, что команды отлиаются тем, как мы их видим . `ps` показывает их в виде таблиц, а `pstree` в виде дерева.

### 3) Изучение /proc

1) Узнаем PID текущей оболочки: `echo $$`

```
2758
```

2) Посмотрим на:

```bash
cat /proc/2758/cmdline | tr '\0' ' '; echo

```

Ожидаем вывод:

```
bash
```
Команда показывает командную строку процесса с PID=2758.

Так как это моя оболочка (bash), там просто написано bash — без аргументов, потому что я запустила стандартный терминал.

Далее посмотрим на:

```bash
head -n 20 /proc/2758/status
```

Ожидаем вывод:

```
Name:	bash
Umask:	0002
State:	S (sleeping)
Tgid:	2758
Ngid:	0
Pid:	2758
PPid:	2751
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	27 1000 
NStgid:	2758
NSpid:	2758
NSpgid:	2758
NSsid:	2758
Kthread:	0
VmPeak:	   19932 kB
VmSize:	   19932 kB
VmLck:	       0 kB
```
Этот файл показывает читаемую сводку о процессе c PID=2758.
осмотрим на:

```bash
ls -l /proc/$$/fd
```

Ожидаем вывод:

```
total 0
lrwx------ 1 yuzefita yuzefita 64 Sep 22 06:40 0 -> /dev/pts/0
lrwx------ 1 yuzefita yuzefita 64 Sep 22 06:40 1 -> /dev/pts/0
lrwx------ 1 yuzefita yuzefita 64 Sep 22 06:40 2 -> /dev/pts/0
lrwx------ 1 yuzefita yuzefita 64 Sep 22 06:40 255 -> /dev/pts/0

```
## 4. Анализ процессов
) Снимите моментальный срез «тяжёлых» процессов по CPU и памяти:

```bash
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
```

2) Посмотрите средние показатели за интервал (CPU/Memory/IO), требуется пакет `sysstat`:

```bash
pidstat -u -r -d 1 5 | cat   # 5 интервалов по 1 сек
```
```
08:55:57 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
08:55:58 PM  1000      2009    6.86    5.88    0.00    0.98   12.75     1  gnome-shell
08:55:58 PM  1000      2751    0.98    0.00    0.00    0.98    0.98     3  gnome-terminal-
08:55:58 PM  1000      2795    1.96    3.92    0.00    0.00    5.88     2  firefox
08:55:58 PM  1000      3239    0.98    0.00    0.00    0.00    0.98     2  WebExtensions
08:55:58 PM  1000      3913    0.98    0.00    0.00    0.00    0.98     3  Isolated Web Co
08:55:58 PM     0     11627    0.00    0.98    0.00    0.00    0.98     4  kworker/u25:3-events_unbound
08:55:58 PM  1000     14119    2.94    1.96    0.00    0.98    4.90     4  Isolated Web Co
08:55:58 PM  1000     14353    1.96    0.98    0.00    0.00    2.94     2  Isolated Web Co
08:55:58 PM  1000     18996    0.00    0.98    0.00    0.00    0.98     4  Web Content

```
Основную CPU нагрузку даёт gnome-shell, далее firefox и Isolated Web Co. 

#TOP-5 процессов по CPU:
```bash
ps -eo pid,comm,pcpu,etime --sort=-pcpu | head -n 6 | column -t
```
Вывод:
```
PID    COMMAND           %CPU  ELAPSED        
3913   Isolated Web Co    5.8  15:10:18
2795   firefox            4.5   15:11:18       
2009   gnome-shell        4.4   15:11:36       
14119  Isolated  Web Co   4.4  02:45:19
13538  Isolated  Web Co   3.5  02:57:31
```
Больше всего нагружает Isolated Web Co

#TOP-5 процессов по памяти:
Команда:
```bash
ps -eo pid,comm,pmem,rss --sort=-pmem | head -n 6 | column -t
```
Вывод:
Команда ничего не возращает. Так как на Ubuntu ограничены права команд

#### Выводы

Нагрузка полностью соответствует запущенным программам. Аномалий и убегающих процессов не обнаружено, 

### 5) Мини‑утилита ptree

Реализуем утилиту на C, которая будет печатать цепочку родителей от текущего процесса до PID 1. Исходный код находится в
`src/ptree.py`

Для запуска:

```bash
python3 ptree.py
```

Пример выполнения:

```
python3(24828) ← bash(2758) ← gnome-terminal-(2751) ← systemd(1763) ← systemd(1)

```

#### Вывод

Утилита успешно отобразила цепочку родительских процессов.
## Вопросы для отчета
1. Чем процесс отличается от программы?

Программа - пассивный файл с кодом на диске, процесс - активное выполнение программы.

2. Что будет, если вызвать `fork()` без `wait()`?

Без `wait()` дочерние процессы после завершения становятся зомби и висят до подбора статуса.

3. Как система хранит информацию о процессах?

Linux хранит информацию о процессах в памяти ядра в структурах task_struct (на поток) и связанных с ней.

4. Что делает `exec()` и зачем он нужен?

Он заменяет текущий процесс другой программой, используется вместе с `fork()` для запуска внешних программ.

5. Почему в `/proc` нет «настоящих» файлов?

`/proc` - виртуальная «файловая»-система, содержимое генерируется ядром при обращении и не хранится на диске

6. Как интерпретировать поля `top`: `%CPU`, `%MEM`, `VIRT`, `RES`, `SHR`, `TIME+`?

`%CPU` — загрузка ядра процессом; `%MEM` — доля RAM ; `VIRT` — всё адресное пространство; `RES` — фактически занятая
RAM; `SHR` — её общая часть; `TIME+` — суммарное CPU-время процесса.

7. Почему сумма `%CPU` может быть больше 100%?

Потому что `%CPU` считается на одно ядро, и поэтому сумма может быть до `100% * #ядер`.

8. Чем отличается мгновенное `%CPU` от `load average`? Что означает строка `Cpu(s)` в `top` (в т.ч. `wa`)?

`%CPU` - текущая доля одного логического ядра за последний интервал, `load average` - среднее числа задач в очереди к CPU +
задачи в состоянии непрерывного ожидания I/O.`Cpu(s)` - разложение времени CPU по категориям за интервал обновления.

- `us` — пользовательский код .
- `sy` — системный код .
- `ni` — пользовательский код с nice приоритетом.
- `id` — простой.
- `wa` — CPU простаивал, пока задачи ждали I/O операции.
- `hi/si` — аппаратные/программные прерывания.
- `st` — CPU был недоступен для текущей виртуальной машины.

9. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть (`pidstat -d`, `iotop`, `/proc/<pid>/io`)?

CPU-нагрузка -  процесс тратит время на вычисление, IO-нагрузка - процесс ждёт диск/сеть. Видны скорости в `pidstat -d`, топ в `iotop`. Для конкретного PID счётчики I/O в `/proc/<pid>/io`.
10. Что такое `nice`/приоритеты процессов и как они влияют на планирование?

`nice` - «вежливость» обычных процессов, чем меньше `NI`, тем выше приоритет и доля CPU. Влияет на долю CPU среди обычных задач, не гарантирует строгих процентов.
11. Чем поток отличается от процесса и как увидеть потоки в `ps`/`top`?

Процесс - контейнер ресурсов, поток — единица выполнения в процессе, делит память/ресурсы, имеет свой TID и планируется отдельно.
Чтобы посмотреть все потоки можно воспользоваться командой `ps -eLf | head`, для конкретного процесса `ps -T -p <pid>`. Также можно и через `top` , показать потоки - `top -H`, для конкретного процесса - `top -H -p <pid>`.
12. Что такое зомби и сироты, как они возникают и куда «деваются»?

Зомби - завершившийся дочерний процесс, у которого родитель ещё не вызвал wait(), висят как `STAT=Z` до подбора статуса. Сироты - живые дети умершего родителя, их усыновляет `PID=1` и дальше они работают нормально.

## Использование ИИ
Помощь с ответами на вопросы.
