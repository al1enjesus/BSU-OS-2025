# **Процессы и файловая система**

## Цель работы

Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из `/proc`.

## Задача 1 - Создание процессов

Написать скрипт (я выбрала Python), создающий два дочерних процесса, а также удерживающего родителя.

Первым делом я создала файл `fork_example.py`, код которого приведен в лабе, получив при этом следующий вывод (при запуске через `python3`):

```bash
vboxuser@ubuntu:~/BSU-OS-2025$ python3 fork_example.py
parent: START, PID=4427
parent: Forked a child with PID=4428
parent: Forked a child with PID=4429
child[0]: PID=4428, PPID=4427
parent: Child with PID=4428 finished with exit code 0
child[1]: PID=4429, PPID=4427
parent: Child with PID=4429 finished with exit code 0
parent: FINISH. Everything is okey.
```

---

## **2) Исследование дерева процессов**

Для сего дела использовались стандартные утилиты `ps` и `pstree`.

*   **`ps -ef --forest`**: Показывает все процессы в системе в виде дерева
*   **`pstree -p`**: Отображает дерево процессов, добавляя к имени каждого процесса его PID.

При этом было получено следующее:

**Команда `ps -ef --forest` (сокращенный вывод):**
```
UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 21:55 ?        00:00:00 [kthreadd]
root           3       2  0 21:55 ?        00:00:00  \_ [pool_workqueue_release]
root           4       2  0 21:55 ?        00:00:00  \_ [kworker/R-rcu_gp]
... (и многие другие системные процессы)
```

**Команда `pstree -p` (сокращенный вывод):**
```
vboxuser@ubuntu:~/BSU-OS-2025$ pstree -p | head -n 50 | cat
systemd(1)-+-ModemManager(1211)-+-{ModemManager}(1234)
           |                    |-{ModemManager}(1237)
           |                    `-{ModemManager}(1241)
           |-NetworkManager(1169)-+-{NetworkManager}(1242)
           |                      |-{NetworkManager}(1244)
           |                      `-{NetworkManager}(1246)
           |-VBoxDRMClient(1984)-+-{VBoxDRMClient}(2000)
... (и многие другие процессы, включая сессию пользователя)
```

Обе команды показали, что запущенные скрипты являются дочерними процессами моей командной оболочки (`bash`).

---

## **3) Изучаю `/proc`**

Я исследовала файлы в виртуальной файловой системе `/proc` для PID текущей оболочки (`echo $$`).

При вводе `echo $$` и получая при этом `4195`, тем самым разузнавая PID для моего процесса, я ввела следующую команду в терминал и получила:

```bash
vboxuser@ubuntu:~/BSU-OS-2025$ cat /proc/4195/cmdline | tr '\0' ' '; echo
bash
```

```bash
vboxuser@ubuntu:~/BSU-OS-2025$ head -n 20 /proc/4195/status
Name:   bash
Umask:  0002
State:  S (sleeping)
Tgid:   4195
Ngid:   0
Pid:    4195
PPid:   4183
TracerPid:      0
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
FDSize: 256
Groups: 27 1000
NStgid: 4195
NSpid:  4195
NSpgid: 4195
NSsid:  4195
Kthread:        0
VmPeak:     12260 kB
VmSize:     12260 kB
VmLck:         0 kB
```

```bash
vboxuser@ubuntu:~/BSU-OS-2025$ ls -l /proc/4195/fd
total 0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 21:57 0 -> /dev/pts/0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 21:57 1 -> /dev/pts/0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 21:57 2 -> /dev/pts/0
lrwx------ 1 vboxuser vboxuser 64 Sep 21 21:57 255 -> /dev/pts/0
```

---

## **4) Анализ процессов**

### TOP-5 по CPU

Команда для получения данных:
```bash
ps -eo pid,comm,%cpu,etime --sort=-%cpu | head -n 6
```

Вывод:
```
  PID COMMAND         %CPU     ELAPSED
 4597 ps               100       00:00
 4559 gjs              4.1       00:05
 3337 gnome-shell      2.9       32:37
 4542 nautilus         2.4       00:06
 4289 gnome-text-edit  1.2       31:42
```

### TOP-5 по памяти

Команда для получения данных:
```bash
ps -eo pid,comm,%mem,rss --sort=-%mem | awk 'NR==1 {print} NR>1 {print $1, $2, $3, $4/1024 " MiB"}' | head -n 6
```

Вывод:
```
  PID COMMAND         %MEM   RSS
 3337 gnome-shell 14.6 499.672 MiB
 4289 gnome-text-edit 7.6 258.719 MiB
 3944 mutter-x11-fram 3.1 106.109 MiB
 3925 gsd-xsettings 2.3 78.8047 MiB
 4559 gjs 2.0 70.3867 MiB
```

### Короткие выводы

Что «нагружает систему» именно у меня и почему:

Основная нагрузка на CPU создаётся утилитой `ps` (100%), что является временным явлением - сама команда измерения потребления ресурсов показывает высокие значения. Из постоянных процессов наибольшую нагрузку создают:

*   `gjs` (4.1%) - процесс выполнения JavaScript в GNOME, вероятно связанный с каким-то расширением или applet
*   `gnome-shell` (2.9%) - графическая оболочка GNOME
*   `nautilus` (2.4%) - файловый менеджер

Память в основном потребляется компонентами графической среды:

*   `gnome-shell` (14.6%, почти 500 МБ) - ядро графической оболочки
*   `gnome-text-edit` (7.6%, около 260 МБ) - текстовый редактор
*   `mutter-x11-fram` (3.1%) - оконный менеджер GNOME

Общая картина показывает, что система используется преимущественно для работы с графическим интерфейсом GNOME и офисными задачами (текстовый редактор), а не для разработки или работы с тяжелыми веб-приложениями. Отсутствие в списке браузеров и сред разработки указывает на более легкий режим использования системы.

Графическая оболочка GNOME является основным потребителем ресурсов, что характерно для этой среды рабочего стола, известной своим относительно высоким потреблением памяти и процессорных ресурсов из-за визуальных эффектов и анимаций.

---

## **5) Мини-утилита `ptree` (\*)**

Мною была написана утилита, которая печатает цепочку родителей от текущего процесса до PID1 (она приведена в файлике `ptree.py`). Поэтому здесь мы рассмотрим лишь вывод:

```bash
python3(4714) ← bash(4195) ← gnome-terminal-(4183) ← systemd(3089) ← systemd(1)
```

Команда была запущена с помощью `python3`. Здесь мы, соответсвенно пришли к PID1, что видно по цепочке.

---

## **Отчетные вопросы**

1.  **Чем процесс отличается от программы?**
    **Программа** — это пассивный набор инструкций на диске (исполняемый файл). **Процесс** — это активный, выполняющийся экземпляр программы с выделенными ресурсами: памятью, PID, файловыми дескрипторами.

2.  **Что будет, если вызвать `fork()` без `wait()`?**
    Возникают две ситуации:
    *   **Процесс-сирота (Orphan):** Если родитель завершается раньше дочернего, дочерний процесс "усыновляется" `init/systemd` (PID 1), который дождётся его завершения.
    *   **Процесс-зомби (Zombie):** Если дочерний процесс завершается, а родитель не вызывает `wait()`, запись о дочернем процессе остаётся в таблице процессов до завершения родителя.

3.  **Как система хранит информацию о процессах?**
    Ядро ОС хранит информацию о каждом процессе в специальной структуре в памяти (в Linux это `task_struct` или PCB). Файловая система `/proc` предоставляет пользовательский интерфейс для доступа к этим данным.

4.  **Что делает `exec()` и зачем он нужен?**
    Системный вызов `exec()` **замещает** текущий образ процесса новым. Он загружает новую программу в адресное пространство *существующего* процесса, сохраняя его PID. Это основной механизм запуска других программ, обычно в паре с `fork()`.

5.  **Почему в `/proc` нет «настоящих» файлов?**
    Потому что `/proc` — это **виртуальная файловая система**. Её содержимое генерируется ядром "на лету" при обращении к нему и отражает текущее состояние системы и процессов. Файлы не хранятся на диске.

6.  **Как интерпретировать поля `top`?**
    *   **`%CPU`**: Процент использования одного ядра CPU.
    *   **`%MEM`**: Процент использования физической RAM.
    *   **`VIRT`**: Общий объём виртуальной памяти.
    *   **`RES`**: Реально используемая физическая память (резидентная).
    *   **`SHR`**: Разделяемая память (часть RES).
    *   **`TIME+`**: Суммарное процессорное время, использованное процессом.

7.  **Почему сумма `%CPU` может быть больше 100%?**
    На многоядерных системах `%CPU` показывает загрузку одного ядра. Значение 200% означает, что процесс полностью утилизирует два процессорных ядра.

8.  **Чем отличается мгновенное `%CPU` от `load average`?**
    *   **`%CPU`** — это моментальный показатель загрузки процессора.
    *   **`Load Average`** — это среднее число процессов в очереди на исполнение за 1, 5 и 15 минут, показатель долгосрочной нагрузки.
    *   `wa` в строке `Cpu(s)` в `top` означает **I/O Wait** — время, которое процессор простаивал в ожидании завершения операций ввода/вывода (например, от диска).

9.  **Чем IO-нагрузка отличается от CPU-нагрузки и как её увидеть?**
    *   **CPU-нагрузка (CPU-bound)** — процесс ограничен скоростью вычислений.
    *   **IO-нагрузка (IO-bound)** — процесс ограничен скоростью диска или сети.
    *   **Как увидеть:** `pidstat -d` (дисковая активность), `iotop`, поле `wa` в `top`, файл `/proc/<pid>/io`.

10. **Что такое `nice`/приоритеты процессов?**
    **`nice`** — это число от -20 (высший приоритет) до 19 (низший), которое влияет на то, как часто планировщик ОС будет выделять процессорное время данному процессу. Процессы с низким значением `nice` получают больше времени CPU.

11. **Чем поток отличается от процесса и как увидеть потоки?**
    **Процессы** имеют изолированные адресные пространства. **Потоки** выполняются в рамках одного процесса и разделяют общее адресное пространство, что делает их более "легковесными".
    *   **Как увидеть:** `ps -T -p <pid>` или нажать `H` в `top`.

12. **Что такое зомби и сироты, как они возникают и куда «деваются»?**
    *   **Сирота (Orphan):** Процесс, чей родитель завершился. "Усыновляется" процессом `init/systemd` (PID 1), который корректно ожидает его завершения.
    *   **Зомби (Zombie):** Процесс, который завершился, но родитель еще не считал его код возврата через `wait()`. "Исчезает", когда родитель вызывает `wait()` или сам завершается.
