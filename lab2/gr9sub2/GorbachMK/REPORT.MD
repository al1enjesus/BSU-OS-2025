# Лабораторная работа 2 - Процессы и файловая система /proc

## Цель
Разобраться с процессами в Linux: fork, exec, wait, а также научиться смотреть информацию о них через /proc.

## 1. Создание процессов
Код: [src/fork_example.c](src/fork_example.c)

Пример вывода программы:
	Parent start: PID=5504
	child[0]: PID=5505,PPID=5504
	child[1]: PID=5506,PPID=5504
	Parent: child PID=5505 exited with status 0
	Parent: child PID=5506 exited with status 0
	Parent end: PID=5504

### Вывод:
Родитель создал двух детей и дождался их завершения.
***
## 2. Исследование дерева процессов


Вывод команды 'ps -ef --forest':
	m6tyz       3935    3423  0 16:14 pts/0    00:00:00  |   |   \_ ./fork_example
	m6tyz       3936    3935  0 16:14 pts/0    00:00:00  |   |       \_ ./fork_example
	m6tyz       3937    3935  0 16:14 pts/0    00:00:00  |   |       \_ ./fork_example
	m6tyz       3940    3438  0 16:14 pts/1    00:00:00  |       \_ grep --color=auto fork_example

Вывод команды 'pstree -p':
	           |               |-gnome-terminal-(3413)-+-bash(3423)---fork_example(3935)-+-fork_example(3936)
                                                                                     `-fork_example(3937)
### Вывод: 
Все процессы получились и выдны в дереве процессов
Родительский процесс я fork_example имеет PID=3935
Дочерние процессы имеют PID=3936 и 3937
bash имеет PID=3423
***
## 3.  Изучение /proc
**PID текущей оболочки:**
`5121`

**Вывод команды** `cat /proc/5121/cmdline |tr '\0' ' '; echo`: 
`bash`
**Пояснение:** командная строка запуска процессора

**Вывод команды** `head -n 20 /proc/5121/status` :
```bash 
Name:	bash
Umask:	0002
State:	S (sleeping)
Tgid:	5121
Ngid:	0
Pid:	5121
PPid:	5114
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	4 24 27 30 46 100 114 1000 
NStgid:	5121
NSpid:	5121
NSpgid:	5121
NSsid:	5121
Kthread:	0
VmPeak:	   19696 kB
VmSize:	   19696 kB
VmLck:	       0 kB
```
**Пояснение:**  основные сведения о процессе: имя, состояние, PID, родитель, пользователь

**Вывод команды**`ls -l /proc/5121/fd` :
```bash
total 0
lrwx------ 1 m6tyz m6tyz 64 сен 23 20:07 0 -> /dev/pts/0
lrwx------ 1 m6tyz m6tyz 64 сен 23 20:07 1 -> /dev/pts/0
lrwx------ 1 m6tyz m6tyz 64 сен 23 20:07 2 -> /dev/pts/0
lrwx------ 1 m6tyz m6tyz 64 сен 23 20:07 255 -> /dev/pts/0
```
**Пояснение:** откртые файловые дискрипторы процесса
***
## 4. Анализ процессов (нагрузка CPU/память/IO)
**Моментальный срез top:**
```bash
top - 23:22:24 up 11 min,  1 user,  load average: 0,04, 0,06, 0,06
Tasks: 460 total,   1 running, 459 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,0 us,  0,4 sy,  0,0 ni, 99,6 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st 
MiB Mem :  15190,5 total,  12504,2 free,   1672,1 used,   1351,6 buff/cache     
MiB Swap:   4096,0 total,   4096,0 free,      0,0 used.  13518,4 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
   3908 m6tyz     20   0   23172   5356   3436 R   9,1   0,0   0:00.02 top
      1 root      20   0   23072  13320   9288 S   0,0   0,1   0:01.77 systemd
      2 root      20   0       0      0      0 S   0,0   0,0   0:00.00 kthreadd
      3 root      20   0       0      0      0 S   0,0   0,0   0:00.00 pool_wo+
      4 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker+
      5 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker+
      6 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker+
      7 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker+
      8 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker+
     10 root      20   0       0      0      0 I   0,0   0,0   0:00.03 kworker+
     11 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker+
     12 root      20   0       0      0      0 I   0,0   0,0   0:00.06 kworker+
     13 root       0 -20       0      0      0 I   0,0   0,0   0:00.00 kworker+
```
**Вывод команды `ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat`: **
```bash
    PID    PPID COMMAND         S %CPU %MEM     ELAPSED
   4020    3733 ps              R  100  0.0       00:00
   4004       2 kworker/0:1-eve I  3.6  0.0       02:20
   3643    3445 obsidian        S  2.9  2.0       41:35
   2605    2331 gnome-shell     S  1.4  1.9       41:50
   3593    3500 obsidian        S  0.9  0.9       41:35
   3996       1 fwupd           S  0.6  0.2       02:21
   3445    2605 obsidian        S  0.4  1.0       41:36
   3524    2605 Xwayland        S  0.3  0.5       41:35
   3910       2 kworker/u97:2-f I  0.2  0.0       30:35
   3725    2331 gnome-terminal- S  0.2  0.4       41:13
   3377       2 kworker/u97:6-f I  0.2  0.0       41:40
    381       2 kworker/14:2-ev I  0.2  0.0       42:14
    374       2 irq/73-ASUF1204 S  0.2  0.0       42:14
   3966       2 kworker/u97:3-e I  0.1  0.0       19:35

```
**Вывод команды `ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat`: **
```bash
    PID    PPID COMMAND         S %CPU %MEM   RSS
   3643    3445 obsidian        S  2.8  2.0 313200
   2605    2331 gnome-shell     S  1.4  1.9 307996
   3445    2605 obsidian        S  0.4  1.0 158864
   3593    3500 obsidian        S  0.9  0.9 146044
   3524    2605 Xwayland        S  0.2  0.5 90084
   3564    2605 mutter-x11-fram S  0.0  0.5 82824
   3537    2331 gsd-xsettings   S  0.0  0.5 79876
   3627    3445 obsidian        S  0.0  0.4 72448
   3225    2605 gjs             S  0.0  0.4 71876
   3725    2331 gnome-terminal- S  0.2  0.4 64576
   2904    2560 evolution-alarm S  0.0  0.3 61236
   3500    3445 obsidian        S  0.0  0.3 51964
   3501    3445 obsidian        S  0.0  0.3 51524
   3996       1 fwupd           S  0.3  0.2 43636

```
**Пояснение:** 
* в top видно процессы с наибольшей нагрузкой на CPU
* процессы fork_example прочти не используют CPU и MEM, поэтому они не попали в первые 20 строк
* для точного отображения fork_example я использую команду `ps -eo pid,ppid,comm,state,%cpu,%mem | grep fork_example`: 
	* Вывод:
		```bash
	   3935    3750 fork_example    S  0.0  0.0
	   3936    3935 fork_example    S  0.0  0.0
	   3937    3935 fork_example    S  0.0  0.0
		```
**Скриншот вывода команды `htop -u "$USER"`:**
![[Screenshot.png]]
**Аналитика процессов**
* TOP-5 по CPU:
	```
	 PID    PPID COMMAND         S %CPU %MEM     ELAPSED
   4431    3733 ps              R  100  0.0       00:00
   3643    3445 obsidian        S  2.7  2.1    01:00:45
   2605    2331 gnome-shell     S  1.6  2.2    01:01:00
   3593    3500 obsidian        S  0.9  0.9    01:00:45
   4247    2331 nautilus        S  0.7  1.0       07:29
	```
	**Пояснение:** 
	- ps  занимает 100% CPU, потому что это командная проверка в момент выполнения
	- fork_exampl не отображается, так как его процессы почти не используют CPU
* TOP-5 по памяти:
	```
	PID    PPID COMMAND         S %CPU %MEM   RSS
   2605    2331 gnome-shell     S  1.6  2.2 354288
   3643    3445 obsidian        S  2.7  2.1 328060
   3445    2605 obsidian        S  0.4  1.0 161464
   4247    2331 nautilus        S  0.7  1.0 161160
   3145    2331 xdg-desktop-por S  0.0  0.9 149920
	```
	**Пояснение:** 
	- gnome-shell и obsidian занимают наибольшее количество памяти
	- fork_example почти не потребляет память, поэтому и не попал в TOP-5
* TOP-5 по IO:
	```
	TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN      IO    COMMAND
      1 be/4 root        0.00 B/s    0.00 B/s ?unavailable?  init splash
      2 be/4 root        0.00 B/s    0.00 B/s ?unavailable?  [kthreadd]
      3 be/4 root        0.00 B/s    0.00 B/s ?unavailable?  [pool_workqueue_release]
      4 be/0 root        0.00 B/s    0.00 B/s ?unavailable?  [kworker/R-rcu_gp]
      5 be/0 root        0.00 B/s    0.00 B/s ?unavailable?  [kworker/R-sync_wq]
	```
	**Пояснение:** 
	- IO-нагрузка минимальна
***
## Ответы на вопросы
1.  Программа - это просто набор инструкций, а процесс - это выполнение этой программыв памяти с ресурсами: памятью, PID и тд.
2. одитель создаст дочерний процесс, но не дождётся его завершения. Если родитель завершится раньше, дочерний станет сиротой и перейдёт под `init`, но если дочерний завершится раньше, но родитель не вызовет `wait()`, он станет зомби — останется в таблице процессов, пока родитель не заберёт статус.  
3. В ядре — через структуру `task_struct`. В пользовательском пространстве — через виртуальную файловую систему `/proc`, где каждый процесс — это каталог `/proc/<PID>` с файлами, отражающими его состояние.  
4. exec() заменяет текущий код процесса на другой. PID остаётся тем же, но вся память, код, данные — обновляются. Используется после fork(), чтобы дочерний процесс запустил другую программу.  
5. Это виртуальная файловая система — файлы создаются ядром.  Они не хранятся на диске, а отображают текущую информацию о процессах, памяти, CPU и т.д.  
6. Поле Значение  
	%CPU Доля CPU, которую использует процесс  
	%MEM Доля оперативной памяти  
	VIRT Вся виртуальная память 
	RES Реально используемая физическая память  
	SHR Общая память, разделяемая с другими процессами  
	TIME+ Общее время CPU, потраченное процессом  
7. На многоядерных системах каждый процесс может использовать несколько ядер.
8. %CPU — текущая загрузка процессора процессом.  load average — среднее количество активных процессов за 1, 5 и 15 минут.  Строка Cpu(s): 
	us — пользовательские процессы  
	sy — системные (ядро)  
	wa — ожидание ввода-вывода  
	id — простаивание  
9. CPU-нагрузка — процесс активно считает.  IO-нагрузка — процесс ждёт данные с диска/сети.  Посмотреть можно через:
	pidstat -d — показывает IO по PID  
	iotop — интерактивный монитор ввода-вывода  
	`/proc/<pid>/io` — подробная статистика IO  
	
10. nice — влияет на приоритет процесса: чем выше nice, тем ниже приоритет.   Планировщик CPU учитывает nice, чтобы решать, кому дать процессор.  
11. Процесс — имеет своё адресное пространство.  Поток — делит память с другими потоками процесса.  В ps можно использовать ps -eLf, в top — нажать H, чтобы показать потоки.  
12. Зомби — завершившийся процесс, чья информация ещё хранится, пока родитель не вызовет wait().  Сирота — процесс, чей родитель завершился.  Зомби исчезают после wait(), сироты — передаются init, который их обслуживает.
