# Лабораторная работа №2 - Процессы и файловая система /proc

## Цель работы
Изучить модель процессов в Linux, принципы создания и управления процессами, а также научиться извлекать информацию из виртуальной файловой системы /proc.

## Выполнение работы

### 1. Создание процессов

**Код программы:** `src/fork_example.c`

**Компиляция и запуск:**
```bash
make fork_example
./fork_example
> Вывод программы:
                                                            
parent: PID=4567, PPID=2345 - Starting
child[0]: PID=4568, PPID=4567
child[1]: PID=4569, PPID=4567
parent: Waiting for children to complete...
parent: Child[0] (PID=4568) exited with code 0
parent: Child[1] (PID=4569) exited with code 0
parent: All children completed. Exiting.
> 2. Исследование дерева процессов

Команды:
    
ps -ef --forest | head -n 20
pstree -p | head -n 20
> 3. Изучение /proc

Текущий PID оболочки: 2345

Исследование файлов /proc:
    
cat /proc/2345/cmdline | tr '\0' ' '; echo
head -n 20 /proc/2345/status
ls -l /proc/2345/fd
> 4. Анализ процессов

TOP-5 по CPU:
    
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 6
> TOP-5 по памяти:
    
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 6
> 5. Утилита ptree

Код программы: src/ptree.c

Компиляция и запуск:
    
make ptree
./ptree $$
          
Пример вывода:
              
Process chain for PID 2345: systemd(1) ← gnome-terminal(1001) ← bash(2345)
> Ответы на вопросы
1. Чем процесс отличается от программы?

Программа - это статичный исполняемый файл с кодом и данными. Процесс - это выполняющийся экземпляр программы с собственным контекстом исполнения, включая регистры, стек, открытые файлы и окружение.
2. Что будет, если вызвать fork() без wait()?

Дочерний процесс станет "зомби" после завершения, так как родитель не получит информацию о его статусе завершения. Зомби-процессы занимают записи в таблице процессов, но не используют ресурсы.
3. Как система хранит информацию о процессах?

В таблице процессов ядра, а также в виртуальной файловой системе /proc, где каждый процесс представлен директорией с соответствующим PID.
4. Что делает exec() и зачем он нужен?

exec() заменяет текущий образ процесса новым исполняемым файлом, сохраняя при этом PID и некоторые атрибуты. Нужен для запуска других программ в контексте текущего процесса.
5. Почему в /proc нет «настоящих» файлов?

/proc - виртуальная файловая система, которая существует только в памяти и предоставляет интерфейс для доступа к информации о ядре и процессах в виде файлов.
    Зомби исчезают когда родитель вызывает wait() или завершаетсяся init)гистры.
> Заключение

В ходе работы изучены принципы работы с процессами в Linux, создание дочерних процессов, ожидание их завершения и анализ информации через /proc. Разработаны программы для демонстрации fork/wait и построения цепочки родительских процессов.
