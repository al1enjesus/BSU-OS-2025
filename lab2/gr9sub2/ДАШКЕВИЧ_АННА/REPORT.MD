## Цель работы:
Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc. Освоить базовые утилиты анализа процессов (ps, pstree, top, pidstat, iotop) и реализовать мини-утилиту ptree.

### Окружение: Ubuntu (Linux 6.14.0-29-generic) в VirtualBox, 4 CPU, RU локаль top

Подготовка среды:
Были установлены пакеты:

build-essential, psmisc, sysstat
Дополнительно использовались: htop, iotop

# Xод работы
## 1) Создание процессов

Запуск программы порождения двух дочерних процессов (Python):

### Команда и вывод:

anya@anya-VirtualBox:~/BSU-OS-2025/lab2/gr9sub2/ДАШКЕВИЧ_АННА/src$ python3 fork_example.py
parent: PID=4026
child_1: PID=4028, PPID=4026
child_0: PID=4027, PPID=4026
parent: child PID=4027 exited with code=0
parent: child PID=4028 exited with code=1
parent: all children finished

### Пояснения:

Родительский процесс напечатал свой PID (4026).
Порождено два дочерних процесса: PID 4027 и 4028, оба с PPID 4026.
Родитель корректно ожидал завершение обоих детей (аналог wait()/waitpid()), отчитался о кодах завершения: 0 и 1, и завершил работу.
Вывод был принудительно сброшен (print(..., flush=True в Python), чтобы строки не терялись при форках.

Ожидаемая визуализация дерева на момент выполнения:

parent(PID=4026)
├─ child_0(PID=4027)
└─ child_1(PID=4028)

## 2) Исследование дерева процессов

### Команда:

ps -ef --forest | head -n 30 | cat

### Вывод:

```
UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 00:29 ?        00:00:00 [kthreadd]
root           3       2  0 00:29 ?        00:00:00  \_ [pool_workqueue_release]
root           4       2  0 00:29 ?        00:00:00  \_ [kworker/R-rcu_gp]
root           5       2  0 00:29 ?        00:00:00  \_ [kworker/R-sync_wq]
root           6       2  0 00:29 ?        00:00:00  \_ [kworker/R-kvfree_rcu_reclaim]
root           7       2  0 00:29 ?        00:00:00  \_ [kworker/R-slub_flushwq]
root           8       2  0 00:29 ?        00:00:00  \_ [kworker/R-netns]
root          10       2  0 00:29 ?        00:00:00  \_ [kworker/0:1-mm_percpu_wq]
root          11       2  0 00:29 ?        00:00:00  \_ [kworker/0:0H-events_highpri]
root          12       2  0 00:29 ?        00:00:00  \_ [kworker/u16:0-ipv6_addrconf]
root          13       2  0 00:29 ?        00:00:00  \_ [kworker/R-mm_percpu_wq]
root          14       2  0 00:29 ?        00:00:00  \_ [rcu_tasks_kthread]
root          15       2  0 00:29 ?        00:00:00  \_ [rcu_tasks_rude_kthread]
root          16       2  0 00:29 ?        00:00:00  \_ [rcu_tasks_trace_kthread]
root          17       2  0 00:29 ?        00:00:00  \_ [ksoftirqd/0]
root          18       2  0 00:29 ?        00:00:02  \_ [rcu_preempt]
root          19       2  0 00:29 ?        00:00:00  \_ [rcu_exp_par_gp_kthread_worker/0]
root          20       2  0 00:29 ?        00:00:00  \_ [rcu_exp_gp_kthread_worker]
root          21       2  0 00:29 ?        00:00:00  \_ [migration/0]
root          22       2  0 00:29 ?        00:00:00  \_ [idle_inject/0]
root          23       2  0 00:29 ?        00:00:00  \_ [cpuhp/0]
root          24       2  0 00:29 ?        00:00:00  \_ [cpuhp/1]
root          25       2  0 00:29 ?        00:00:00  \_ [idle_inject/1]
root          26       2  0 00:29 ?        00:00:00  \_ [migration/1]
root          27       2  0 00:29 ?        00:00:00  \_ [ksoftirqd/1]
root          28       2  0 00:29 ?        00:00:01  \_ [kworker/1:0-events]
root          29       2  0 00:29 ?        00:00:00  \_ [kworker/1:0H-events_highpri]
root          30       2  0 00:29 ?        00:00:00  \_ [cpuhp/2]
root          31       2  0 00:29 ?        00:00:00  \_ [idle_inject/2]
```

### Комментарий:

Отображается фрагмент дерева начиная с ядровых потоков (kthreadd и kworker*).
Для пользовательских процессов в полном выводе можно было бы увидеть «ветку» от systemd(1) → окружение рабочего стола → терминал → bash → текущие процессы.
Также дополнительно использовалась команда pstree (в задании), но её вывод не приложен — ориентировались на ps --forest и ptree ниже.

## 3) Изучение /proc

### Определение PID текущей оболочки:

echo $$
3565

### Просмотр cmdline, status, fd для PID 3565 (bash):

cat /proc/3565/cmdline | tr '\0' ' '; echo
head -n 20 /proc/3565/status
ls -l /proc/3565/fd

### Вывод:

```
/usr/bin/bash --init-file /usr/share/code/resources/app/out/vs/workbench/contrib/terminal/common/scripts/shellIntegration-bash.sh 

Name:   bash
Umask:  0002
State:  S (sleeping)
Tgid:   3565
Ngid:   0
Pid:    3565
PPid:   3523
TracerPid:      0
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
FDSize: 256
Groups: 4 24 27 30 46 100 115 1000 
NStgid: 3565
NSpid:  3565
NSpgid: 3565
NSsid:  3565
Kthread:        0
VmPeak:    21124 kB
VmSize:    21124 kB
VmLck:         0 kB
```

итого 0

```
lrwx------ 1 anya anya 64 сен 21 00:36 0 -> /dev/pts/1
lrwx------ 1 anya anya 64 сен 21 00:36 1 -> /dev/pts/1
lr-x------ 1 anya anya 64 сен 21 00:36 103 -> /usr/share/code/v8_context_snapshot.bin
lrwx------ 1 anya anya 64 сен 21 00:36 2 -> /dev/pts/1
lrwx------ 1 anya anya 64 сен 21 00:36 255 -> /dev/pts/1
l-wx------ 1 anya anya 64 сен 21 00:36 41 -> /home/anya/.config/Code/logs/20250921T003553/ptyhost.log
```

### Пояснения:

/proc//cmdline — командная строка процесса (аргументы, разделённые NUL; мы заменили на пробелы командой tr).
/proc//status — сводка по процессу: состояние (State), идентификаторы (Pid, PPid, Uid, Gid), группы, лимиты и часть метрик памяти (VmSize и др.).
/proc//fd — каталог с открытыми файловыми дескрипторами; симлинки указывают на текущие привязки (0,1,2 к /dev/pts/1 — терминал; есть лог VS Code ptyhost.log; и др.).

## 4) Анализ процессов (CPU/память/IO)

### Команды:

```
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
pidstat -u -r -d 1 5 | cat
sudo iotop -b -n 5 | head -n 30 | cat
```

### Часть вывода top (сводка):

top - 00:45:14 up 15 min,  2 users,  load average: 0,55, 0,77, 0,55
Задачи: 249 total,   1 running, 248 sleeping,   0 stopped,   0 zombie
%Cpu(s): 34,3 us, 22,9 sy,  0,0 ni, 42,9 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st 
МиБ Mem :   3402,7 total,    405,9 free,   1755,4 used,   1564,0 buff/cache   
МиБ Swap:   3914,0 total,   3914,0 free,      0,0 used.   1647,3 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+
   1884 anya      20   0 5047520 428456 158424 S  16,7  12,3   1:29.15
   3439 anya      20   0 1409,7g 354240 143612 S   8,3  10,2   1:27.61
   4356 anya      20   0   22196   5632   3584 R   8,3   0,2   0:00.02
      1 root      20   0   25052  15584  10848 S   0,0   0,4   0:02.07
...

### TOP-15 по CPU (моментальный срез ps):

```
PID    PPID COMMAND         S %CPU %MEM     ELAPSED
4359    3565 ps              R 66.6  0.1       00:00
3402    3365 code            S 16.1  4.8       09:21
3439    3368 code            R 15.6 10.1       09:20
1884    1616 gnome-shell     S  9.4 12.2       15:40
3358    1884 code            S  3.9  5.3       09:22
3523    3358 code            S  1.7  3.2       09:15
3483    3358 code            S  1.5  3.1       09:16
3473    3358 code            S  1.5  4.6       09:17
2437    1884 Xwayland        S  0.8  2.4       15:36
2944    1616 gnome-terminal- S  0.5  1.6       12:16
3484    3358 code            S  0.4  2.9       09:16
1510       1 VBoxDRMClient   S  0.3  0.0       15:41
2241    2088 ibus-extension- S  0.3  0.9       15:36
1102       1 snapd           S  0.3  1.1       15:43
```

### TOP-15 по памяти (ps по RSS):

```
PID    PPID COMMAND         S %CPU %MEM   RSS
1884    1616 gnome-shell     S  9.4 12.2 428456
3439    3368 code            S 15.6 10.1 354280
3358    1884 code            S  3.9  5.3 187484
3402    3365 code            S 16.1  4.8 170432
3473    3358 code            S  1.5  4.6 162132
3523    3358 code            S  1.7  3.2 113064
3483    3358 code            S  1.5  3.1 110684
2618    1884 mutter-x11-fram S  0.1  3.1 109436
3484    3358 code            S  0.4  2.9 104328
3582    3473 code            S  0.2  2.5 88876
2437    1884 Xwayland        S  0.8  2.4 84908
2600    1616 gsd-xsettings   S  0.0  2.3 81640
3412    3358 code            S  0.1  2.0 72376
2140    1844 evolution-alarm S  0.0  1.8 66072
```

### pidstat (5 интервалов по 1 сек; фрагменты):

Linux 6.14.0-29-generic (anya-VirtualBox)       21.09.2025      _x86_64_        (4 CPU)

00:45:14      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
00:45:15        0        43    0,00    0,95    0,00    0,95    0,95     1  kworker/u18:0-events_unbound
...

00:45:15     1000      1884    2,86    2,86    0,00    0,95    5,71     2  gnome-shell
00:45:15     1000      3402   10,48    4,76    0,00    0,00   15,24     3  code
00:45:15     1000      3439    5,71    4,76    0,00    1,90   10,48     3  code
...

Среднее:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Среднее:  1000      1884   11,29   10,30    0,00    3,37   21,58     -  gnome-shell
Среднее:  1000      2437    1,19    0,99    0,00    2,18    2,18     -  Xwayland
Среднее:  1000      3358    0,59    1,19    0,00    0,59    1,78     -  code
Среднее:  1000      3402   14,85    7,92    0,00    0,00   22,77     -  code
Среднее:  1000      3439   18,22   10,30    0,00    2,57   28,51     -  code
...

### Блок памяти pidstat -r (фрагменты):

00:45:15      UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
00:45:15     1000      1884     44,76      9,52 5042736  428456  12,30  gnome-shell
...
Среднее:   UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
Среднее:  1000      1884    340,99     43,56 5043693  429912  12,34  gnome-shell
Среднее:  1000      3439    259,21      0,00 1478142840  351401  10,09  code
...

### iotop (5 итераций, первые 30 строк):

Total DISK READ:         3.29 K/s | Total DISK WRITE:         0.00 B/s
Current DISK READ:       0.00 B/s | Current DISK WRITE:       0.00 B/s
    TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN      IO    COMMAND
      1 be/4 root        0.00 B/s    0.00 B/s ?unavailable?  init splash
      2 be/4 root        0.00 B/s    0.00 B/s ?unavailable?  [kthreadd]
...
     28 be/4 root        0.00 B/s    0.00 B/s ?unavailable?  [kworker/1:0-mm_percpu_wq]

## Краткая аналитика процессов:

### TOP‑5 по CPU (моментальный срез, по ps):

ps (PID 4359) — 66.6% (артефакт измерения, сам ps потребил CPU при сборе данных).
code (PID 3402) — 16.1%
code (PID 3439) — 15.6%
gnome-shell (PID 1884) — 9.4%
code (PID 3358) — 3.9%

### Комментарий: 
Основными потребителями CPU являются процессы редактора/IDE (Visual Studio Code — несколько процессов/пайпов) и окружение рабочего стола (gnome-shell). На многоядерной системе %CPU суммируется по ядрам, поэтому общая сумма может превышать 100%.

### TOP‑5 по памяти (по RSS из ps):

gnome-shell (PID 1884) — %MEM 12.2, RSS ~428 MiB
code (PID 3439) — %MEM 10.1, RSS ~354 MiB
code (PID 3358) — %MEM 5.3, RSS ~187 MiB
code (PID 3402) — %MEM 4.8, RSS ~170 MiB
code (PID 3473) — %MEM 4.6, RSS ~162 MiB

### Комментарий: существенная часть памяти занята VS Code (несколько процессов) и gnome-shell.
(Опционально) IO:
По iotop в момент съёмки активных операций чтения/записи почти нет (0 B/s). Виртуальная машина и простои — ожидаемо низкая IO-нагрузка.

### Выводы по нагрузке:

Систему нагружают в основном процессы Visual Studio Code и gnome-shell (как по CPU, так и по памяти).
IO‑нагрузка минимальна в момент измерения.
Показатели pidstat усреднённо подтверждают доминирование «code» и «gnome-shell» по CPU.

### Примечание:

Работа выполнялась в VirtualBox; в виртуалке метрики могут отличаться от «железа» (например, по таймингам планировщика, поведению драйверов видео, доступной памяти). Учитывали это в интерпретации.

## 5) Мини‑утилита ptree
Запуск:

python3 ptree.py
python3(4510) ← bash(3565) ← code(3523) ← code(3358) ← gnome-shell(1884) ← systemd(1616) ← systemd(1)

### Пояснение:

Утилита читает PPid из /proc//status и строит цепочку родителей от текущего процесса до PID 1.
Видно, что bash запущен из процесса code (VS Code integrated terminal), далее вверх — gnome-shell → systemd (user) → systemd(1).

## Ответы на вопросы:

### Чем процесс отличается от программы?
Программа — это пассивный набор инструкций/файл на диске. Процесс — активное выполнение программы с уникальным PID, собственным адресным пространством, контекстом (регистры, стек), открытыми дескрипторами и окружением.

### Что будет, если вызвать fork() без wait()?
Дочерний процесс будет создан и может завершиться раньше родителя. Если родитель не вызовет wait()/waitpid(), завершившиеся дети становятся «зомби» до тех пор, пока родитель не соберёт их статус или пока родитель не завершится (тогда зомби будут усыновлены init/systemd и очищены).

### Как система хранит информацию о процессах?
В ядре есть структуры (task_struct и др.) c состоянием процесса. Пользовательское пространство получает представление через виртуальную FS /proc (каталоги /proc/), а также через системные вызовы. /proc отражает актуальное состояние ядра в виде «виртуальных» файлов.

### Что делает exec() и зачем он нужен?
Семейство exec заменяет образ текущего процесса новым (загрузка другой программы в то же адресное пространство с тем же PID). Используется для запуска программы после fork(): ребёнок делает exec и превращается в другую команду.

### Почему в /proc нет «настоящих» файлов?
/proc — виртуальная файловая система. Её содержимое генерируется ядром на лету, отражая текущее состояние. Это интерфейс к данным ядра, а не хранилище на диске.

### Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?
%CPU — доля CPU, потребляемая процессом (на многоядерной системе суммарно может быть >100%).
%MEM — доля физической памяти (RAM), занимаемая процессом.
VIRT — виртуальный объём адресного пространства (включая маппинги, не обязательно в RAM).
RES — резидентная память (фактически в RAM).
SHR — разделяемая резидентная память.
TIME+ — суммарное CPU‑время процесса (user+system).

### Почему сумма %CPU может быть больше 100%?
На мультикоре 100% соответствует одному ядру. На 4 ядрах теоретический максимум ~400%. Процесс может использовать несколько потоков на разных ядрах.

### Чем отличается мгновенное %CPU от load average? Что означает строка Cpu(s) в top (в т.ч. wa)?
%CPU — мгновенное использование CPU конкретным процессом или суммарно.
load average — средняя длина очереди выполнения/число задач, требующих CPU или ожидающих IO, усреднённое за 1/5/15 мин.
В строке Cpu(s): us — пользовательское время, sy — системное, ni — с «nice», id — простой, wa — ожидание IO, hi/si — обработки аппаратных/программных прерываний, st — отнято гипервизором.
Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть (pidstat -d, iotop, /proc//io)?
CPU‑нагрузка — использование вычислительных ресурсов; IO‑нагрузка — активность чтения/записи (диск/сеть). Видна через pidstat -d (IO‑метрики по PID), iotop (онлайн IO по процессам), /proc//io (счётчики чтений/записей).

### Что такое nice/приоритеты процессов и как они влияют на планирование?
nice — «вежливость» процесса (от -20 до +19): ниже значение — выше приоритет на CPU. Планировщик учитывает nice/приоритеты при распределении квантов времени.

### Чем поток отличается от процесса и как увидеть потоки в ps/top?
Потоки делят адресное пространство и ресурсы одного процесса (легковеснее), у каждого свой TID. В ps можно использовать опции для потоков (например, ps -eLf), в top — клавиша H (показать потоки).

### Что такое зомби и сироты, как они возникают и куда «деваются»?
Зомби — завершившиеся процессы, статус которых не собрал родитель (висят до wait()).
Сироты — процессы, чьи родители завершились; усыновляются init/systemd и далее управляются им. Зомби «исчезают» после wait() родителя или усыновления init/systemd.
Проверка
Реализована программа с fork() и корректным ожиданием дочерних (Python): выведены PID/PPID и коды завершения.
Приведены команды и вывод ps/top/pidstat/iotop, а также содержимое файлов в /proc/ с пояснениями.
Оформлена аналитика TOP‑5 по CPU и памяти (и наблюдение по IO).
Реализована и продемонстрирована утилита ptree (цепочка до PID 1).

## Ответы на новые вопросы:

### Проверяли ли работу кода на других дистрибутивах Linux кроме Ubuntu?
Код проверялся только на Ubuntu. 

### Почему выбрали Python вместо C для демонстрации системных вызовов?
Код на Python получается более коротким и читаемым. А так же отсутствие этапа компиляции ускоряет цикл написания и тестирования кода.

### Как поведёт себя ptree.py, если процесс с указанным PID завершится во время выполнения?
Если целевой процесс или любой из его предков завершится во время построения цепочки, попытка открыть его каталог в /proc (например, /proc/4026/status) завершится ошибкой, так как каталог будет удалён. Это приведёт к возбуждению исключения (например, FileNotFoundError в Python), и программа аварийно завершится. 

### Рассматривали ли вариант обработки ситуации, когда init-процесс не systemd?
Не рассматривала. Алгоритм завершает работу при достижении процесса с PID 1, предполагая, что это корневой родитель. 

### Какие ещё поля из /proc/<PID>/status могли бы быть полезны для анализа процесса?
Файл /proc/<PID>/status содержит множество полезных полей:

State (S): Текущее состояние процесса (Running, Sleeping, Zombie, etc.). Критически важно для понимания, что делает процесс.

Umask: Маска прав доступа, применяемая по умолчанию при создании новых файлов.

Uid / Gid: Реальные, эффективные, сохранённые и файловые идентификаторы пользователя и группы. Полезны для анализа прав доступа.

VmPeak / VmSize / VmRSS / VmData: Детальная информация об использовании виртуальной и физической памяти процессом. Позволяет глубоко анализировать потребление памяти.

Threads: Количество потоков в процессе. Прямо указывает на многопоточность.

voluntary_ctxt_switches / nonvoluntary_ctxt_switches: Количество добровольных и принудительных переключений контекста. Показатель активности процесса и нагрузки на планировщик.

## Выводы
Закреплена модель процессов Linux: порождение (fork), подмена образа (exec), ожидание завершения (wait/waitpid).
Освоены способы чтения состояния процессов через /proc и системные утилиты анализа.
В практическом окружении VirtualBox основные потребители ресурсов — процессы редактора VS Code и окружения gnome-shell.
/proc, как виртуальная FS, наглядно показывает текущее состояние ядра/процессов без «реальных» файлов на диске.

### Приложение: команды, использованные в работе
Порождение процессов: python3 src/fork_example.py
Дерево процессов: ps -ef --forest | head -n 30 | cat
PID текущей оболочки: echo $$
/proc:
cat /proc//cmdline | tr '\0' ' '; echo
head -n 20 /proc//status
ls -l /proc//fd

### Аналитика:
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
pidstat -u -r -d 1 5 | cat
sudo iotop -b -n 5 | head -n 30 | cat
ptree: python3 src/ptree.py