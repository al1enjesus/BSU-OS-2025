# Лабораторная 2 — Процессы и файловая система /proc

## Как использовали AI
AI не был использован.

## Как проверить?
Makefile лежит в ./ , исходники программ в ./src/ . Выполнение скриптов и целей Makefile даст нужные результаты обеспечив воспроизводимость.

### Цели Makefile
- all: запуск ptree с запросом pid, после завершения запуск fork_example
- clean: очистить папку от файлов компиляции
- run_ptree: запустить ptree
- run_fork_example: запустить fork_example

## Цель
Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc.

## Задание 1. Создание процессов
### Задача
Родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

### Шаги решения
Запустив `make run_fork_example` получим PID родителя и дочерних и PPID дочерних. Родительский процесс порождает дочерних в цикле при помощи `fork()` и ожидает их при помощи `wait()`.

### Полученный результат:
```
    parent(PID=4610)
    -child[0](PID=4611, PPID=4610)
    -child[1](PID=4612, PPID=4610)
```
### Ключевые выводы
Функция fork() создает точную копию родительского процесса, включая состояние памяти, открытые файлы и контекст выполнения. Функция wait() обеспечивает синхронизацию, позволяя родителю приостановить свое выполнение до завершения работы дочернего процесса.

## Задание 2. Исследование дерева процессов
### Задача
Найдите свой процесс и родителей и сравнить результаты 2-ух команд `ps` и `pstree`.

### Шаги решения
Запустить команды `ps -ef --forest | less` и `pstree -p | less` в терминале найти процесс и сравнить результаты.

### Полученный результат
```
UID          PID    PPID  C STIME TTY          TIME CMD
killers+    1737       1  0 20:12 ?        00:00:00 /usr/lib/systemd/systemd --user
killers+    3852    1737  0 20:13 ?        00:00:04  \_ /usr/libexec/gnome-terminal-server
killers+    3860    3852  0 20:13 pts/0    00:00:00  |   \_ bash
killers+    5134    3860  0 20:53 pts/0    00:00:00  |   |   \_ ps -ef --forest
killers+    5135    3860  0 20:53 pts/0    00:00:00  |   |   \_ cat
killers+    5113    3852  0 20:53 pts/1    00:00:00  |   \_ bash
killers+    5129    5113  0 20:53 pts/1    00:00:00  |       \_ ./fork_example
killers+    5130    5129  0 20:53 pts/1    00:00:00  |           \_ ./fork_example
killers+    5131    5129  0 20:53 pts/1    00:00:00  |           \_ ./fork_example
--------------------------------------------------------------------------------------
systemd(1)-+-ModemManager(879)-+-{ModemManager}(893)
           |-systemd(1737)-+-(sd-pam)(1743)
           |               |-gnome-terminal-(3852)-+-bash(3860)-+-cat(5138)
           |               |                       |            `-pstree(5137)
           |               |                       |-bash(5113)---fork_example(5129)-+-fork_example(5130)
           |               |                       |                                 `-fork_example(5131)
```

### Ключевые выводы
`ps -ef --forest` отображает больше технических деталей процессов, а `pstree -p` понятную иерархию процессов.

## Задание 3. Изучение /proc
### Задача
Научиться работать с `/proc/<pid>/...`

### Шаги решения
1. Узнайте PID текущей оболочки: echo $$.

2. Посмотрите:
```
cat /proc/<pid>/cmdline | tr '\0' ' '; echo
head -n 20 /proc/<pid>/status
ls -l /proc/<pid>/fd
```
### Полученный результат
```
3860
-----------------------------------------------------------------
bash 
-----------------------------------------------------------------
Name:	bash
Umask:	0002
State:	S (sleeping)
Tgid:	3860
Ngid:	0
Pid:	3860
PPid:	3852
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	4 24 27 30 46 100 114 1000 
NStgid:	3860
NSpid:	3860
NSpgid:	3860
NSsid:	3860
Kthread:	0
VmPeak:	   19692 kB
VmSize:	   19692 kB
VmLck:	       0 kB
-----------------------------------------------------------------
total 0
lrwx------ 1 killerser killerser 64 Sep 21 20:14 0 -> /dev/pts/0
lrwx------ 1 killerser killerser 64 Sep 21 20:14 1 -> /dev/pts/0
lrwx------ 1 killerser killerser 64 Sep 21 20:14 2 -> /dev/pts/0
lrwx------ 1 killerser killerser 64 Sep 21 20:14 255 -> /dev/pts/0
```
### Ключевые выводы
1. cmdline показывает полную командную строку запуска процесса с аргументами.
2. status показывает детальную информацию о состоянии процесса. Первые 20 строк включают:
- Name: имя процесса
- Umask: маска прав доступа
- Tgid: Thread group ID
- Ngid: NUMA group ID 
- State: текущее состояние процесса
- Pid, PPid: идентификаторы процесса и родителя
- TracerPid: ID отладчика
- UID/GID: реальные, эффективные, сохраненные, файловые идентификаторы пользователя/группы
- FDSize: количество файловых дескрипторов
- Groups: список групп процесса
- NStgid: ID группы потоков в каждом из пространств имен
- NSpid: ID потока в каждом из пространств имен
- NSpgid: ID группы процессов в каждом из пространств имен
- NSsid: иерархический идентификатор сеанса в каждом из пространств имен
- VmPeak: пиковое использование виртуальной памяти
- VmSize: текущий размер виртуальной памяти
- VmLck: заблокированная память
- VmPin: Pinned memory (не может быть своппирована)
3. fd показывает список открытых файловых дескрипторов процесса:
- 0 -> /dev/pts/0: stdin (стандартный ввод)
- 1 -> /dev/pts/0: stdout (стандартный вывод) 
- 2 -> /dev/pts/0: stderr (стандартная ошибка)
- 255 -> /dev/pts/0: дополнительный дескриптор оболочки

## Задание 4. Анализ процессов (нагрузка CPU/память/IO)
### Задача
Научиться анализировать живые процессы

### Шаги решения
1. Снимите моментальный срез «тяжёлых» процессов по CPU и памяти:
```
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
```
2. Посмотрите средние показатели за интервал (CPU/Memory/IO), требуется пакет sysstat:
```
pidstat -u -r -d 1 5 | cat   # 5 интервалов по 1 сек
```

### Полученный результат
```
top - 23:24:01 up  3:12,  1 user,  load average: 0.46, 0.33, 0.32
Tasks: 284 total,   1 running, 281 sleeping,   1 stopped,   1 zombie
%Cpu(s):  1.1 us,  1.1 sy,  0.0 ni, 96.6 id,  1.1 wa,  0.0 hi,  0.0 si,  0.0 st 
MiB Mem :  10827.8 total,   4606.7 free,   3256.8 used,   2473.2 buff/cache     
MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.   7571.0 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
   2427 killers+  20   0  245436   7400   6760 S  10.0   0.1   0:07.90 ibus-en+
      1 root      20   0   23436  14136   9272 S   0.0   0.1   0:01.10 systemd
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.00 kthreadd
      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_wo+
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      5 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      7 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
      8 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
     10 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
     13 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker+
     14 root      20   0       0      0      0 I   0.0   0.0   0:00.00 rcu_tas+
     15 root      20   0       0      0      0 I   0.0   0.0   0:00.00 rcu_tas+
--------------------------------------------------------------------------------
    PID    PPID COMMAND         S %CPU %MEM     ELAPSED
   1984    1737 gnome-shell     S 14.5  4.2    03:11:24
   2683    1984 firefox         S  5.9  7.7    03:11:06
  15323    2960 Isolated Web Co S  1.2  3.2       44:37
  18933    2960 Isolated Web Co S  0.9  2.3       05:57
  16731    2960 Isolated Web Co S  0.9  1.6       31:41
  18857    2960 Isolated Web Co S  0.8  1.9       05:58
  19260    2960 Isolated Web Co S  0.8  1.7       03:16
   3852    1737 gnome-terminal- S  0.5  0.6    03:10:27
  19253    2960 Isolated Web Co S  0.3  1.4       03:16
   7703    2960 Isolated Web Co S  0.2  1.4    02:09:06
  11082    2960 Isolated Web Co S  0.2  2.3    01:23:41
  14530    2960 Isolated Web Co S  0.2  2.1       52:52
  18864    2960 Isolated Web Co S  0.1  1.3       05:58
   5842    2960 Isolated Web Co S  0.1  1.9    02:14:08
---------------------------------------------------------------------------------
    PID    PPID COMMAND         S %CPU %MEM   RSS
   2683    1984 firefox         S  5.9  7.7 885856
   1984    1737 gnome-shell     S 14.5  4.2 481448
  15323    2960 Isolated Web Co S  1.2  3.2 370768
   4482    1737 nautilus        S  0.1  2.6 296080
  18933    2960 Isolated Web Co S  0.9  2.3 269556
  11082    2960 Isolated Web Co S  0.2  2.3 264492
  14530    2960 Isolated Web Co S  0.2  2.1 249136
   5842    2960 Isolated Web Co S  0.1  1.9 220008
  18857    2960 Isolated Web Co S  0.8  1.9 219804
  15280    2960 Isolated Web Co S  0.1  1.7 197296
  19260    2960 Isolated Web Co S  0.8  1.7 196248
   3662    2960 Isolated Web Co S  0.1  1.6 191948
  16731    2960 Isolated Web Co S  0.9  1.6 191672
   8583    2960 Isolated Web Co S  0.0  1.5 179984
---------------------------------------------------------------------------------
Результаты 2-ого пункта лежат в ./logs/4_4.txt
```
### Ключевые выводы
TOP-5 процессов по CPU
Источник: ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu
```
PID	COMMAND	%CPU	ETIME	Причина
1984	gnome-shell	14.5	03:11:24	Графическая оболочка GNOME
2683	firefox	5.9	03:11:06	Веб-браузер Firefox
15323	Isolated Web Co	1.2	44:37	Web-процесс
18933	Isolated Web Co	0.9	05:57	Web-процесс
16731	Isolated Web Co	0.9	31:41	Web-процесс
```

TOP-5 процессов по памяти
Источник: ps -eo pid,ppid,comm,state,%mem,rss --sort=-%mem
```
PID	COMMAND	%MEM	RSS (MiB)	Причина
2683	firefox	7.7	865	Веб-браузер с открытыми вкладками
1984	gnome-shell	4.2	470	Графическая оболочка GNOME
15323	Isolated Web Co	3.2	362	Web-процесс с контентом
4482	nautilus	2.6	289	Файловый менеджер
18933	Isolated Web Co	2.3	263	Web-процесс
```
Анализ нагрузки системы  
- Графическое окружение GNOME - основной потребитель CPU (до 15%)
- Веб-браузер Firefox - главный потребитель памяти (866 MB)

## Задание 5. Мини‑утилита ptree (*)
### Задача
Напишите утилиту, печатающую цепочку родителей от текущего процесса до PID 1 (init/systemd).

### Шаги решения
Читаем из `/proc/<pid>/status` имя процесса его PID и PID родителя. Повторяем всё для родителя пока не дойдём до конца. Начальный PID можно задать аргументом при запуске или ввести после запуска мини-утилиты.


### Полученный результат
```
bash(3860) <- gnome-terminal-(3852) <- systemd(1737) <- systemd(1)
```

## Ответы на вопросы
1. Чем процесс отличается от программы? (Программа - статичный исполняемый файл на диске (код + данные), а процесс - экземпляр выполняющейся программы в памяти, включающий код, данные (стек, heap), регистры процессора, открытые файлы и ресурсы, контекст выполнения)
2. Что будет, если вызвать `fork()` без `wait()`? (Родительский процесс не узнает статус завершения потомка, дочерний процесс завершится, но останется зомби (zombie) в таблице процессов)
3. Как система хранит информацию о процессах? (В таблице процессов в ядре, дескрипторах процессов, /proc виртуальной файловой системе с информацией о каждом процессе)
4. Что делает `exec()` и зачем он нужен? (exec() заменяет текущий образ процесса новым образом из исполняемого файла, нужен для запуска других программ из текущего процесса)
5. Почему в `/proc` нет «настоящих» файлов? (/proc - это виртуальная файловая система (procfs), которая предоставляет интерфейс для доступа к структурам данных ядра)
6. Как интерпретировать поля `top`: `%CPU`, `%MEM`, `VIRT`, `RES`, `SHR`, `TIME+`? (%CPU: Процент времени CPU, используемого процессом, %MEM: Процент физической памяти, используемой процессом, VIRT: Общая виртуальная память (код + данные + стек + swap), RES: Resident Set Size - физическая память в RAM, SHR: Shared memory - разделяемая память (библиотеки и т.д.), TIME+: Общее время CPU, использованное процессом)
7. Почему сумма `%CPU` может быть больше 100%? (В многопроцессорных системах каждое ядро считается как 100%)
8. Чем отличается мгновенное `%CPU` от `load average`? Что означает строка `Cpu(s)` в `top` (в т.ч. `wa`)? (Мгновенное %CPU - использование в текущий момент. Load average - средняя нагрузка за 1, 5 и 15 минут (количество процессов в очереди на выполнение).  
Строка Cpu(s) в top:
- us: user processes (%)
- sy: system (kernel) processes (%)
- ni: nice processes (%)
- id: idle (%)
- wa: I/O wait (%) - время ожидания завершения I/O операций
- hi: hardware interrupts (%)
- si: software interrupts (%)
- st: stolen (виртуализация)  
)
9. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть (`pidstat -d`, `iotop`, `/proc/<pid>/io`)? (CPU-нагрузка - время выполнения инструкций процессора. I/O-нагрузка - время ожидания операций ввода-вывода (диск, сеть). pidstat -d - I/O статистика по процессам, iotop - аналог top для I/O, /proc/<pid>/io - детальная I/O статистика процесса)
10. Что такое `nice`/приоритеты процессов и как они влияют на планирование? (Nice value (-20 до 19) - влияет на приоритет планировщика, где -20 - высший приоритет, 19 - низший приоритет, по умолчанию: 0.Влияние: Процессы с higher nice (низкий приоритет) получают меньше времени CPU относительно процессов с lower nice.)
11. Чем поток отличается от процесса и как увидеть потоки в `ps`/`top`? (Процесс - изолированное окружение выполнения с отдельной памятью. Поток - часть процесса, разделяющая его память и ресурсы. ps -eLf - показать потоки. top -H - показать потоки вместо процессов)
12. Что такое зомби и сироты, как они возникают и куда «деваются»? (Зомби (zombie) - завершенный процесс, но его запись еще в таблице процессов (родитель не вызвал wait()). Сироты (orphans) - процессы, чей родитель завершился (усыновляются init). Как возникают:
- Зомби: родитель не вызвал wait() после завершения потомка
- Сироты: родитель завершился раньше потомка  
Куда деваются:
- Зомби: исчезают когда родитель вызывает wait() или завершается
- Сироты: продолжают выполняться под управлением init (PID 1)  
)