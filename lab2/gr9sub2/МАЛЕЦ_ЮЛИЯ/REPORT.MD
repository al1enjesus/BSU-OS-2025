# Лабораторная работа 2 - Процессы и файловая система /proc

## Цель лабораторной работы: Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc.

# Пункт 1 ( Создание процессов (Python)):

### Реализовала программу на Python, в которой родительский процесс порождает двух дочерних. Каждый дочерний выводит свой PID и PPID. Родитель ожидает завершения обоих и выводит их коды завершения.


## Код fok_example.py:
```
import os
import sys

def create_child(index):
    pid = os.fork()
    if pid == 0:
        print(f"child[{index}]: PID={os.getpid()}, PPID={os.getppid()}", flush=True)
        sys.exit(index)
    return pid

def main():
    print(f"Parent started. PID={os.getpid()}", flush=True)

    children = []
    for i in range(2):
        pid = create_child(i)
        children.append(pid)

    for _ in children:
        pid, status = os.wait()
        exit_code = os.WEXITSTATUS(status)
        print(f"Child PID={pid} exited with code {exit_code}", flush=True)

    print(f"Parent finished. PID={os.getpid()}", flush=True)

if __name__ == "__main__":
    main()
```


## Ожидаемый вывод:
```
Parent started. PID=1234 
child[0]: PID=1235, PPID=1234 
child[1]: PID=1236, PPID=1234 
Child PID=1235 exited with code 0 
Child PID=1236 exited with code 1 
Parent finished. PID=1234
```

## Вывод:
```
Parent started. PID=5716
child[0]: PID=5717, PPID=5716
child[1]: PID=5718, PPID=5716
Child PID=5717 exited with code 0
Child PID=5718 exited with code 1
Parent finished. PID=5716
```

## Итог пункта 1:
* `os.fork()` создаёт копию текущего процесса.
* `os.wait()` позволяет родителю дождаться завершения дочернего.
* PID - уникальный идентификатор процесса, PPID - идентификатор родителя.









# Пункт 2 (Исследование дерева процессов)

## Команды:
```
ps -ef --forest | head -n 30 | cat
```

## Вывод:
```
UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 13:18 ?        00:00:00 [kthreadd]
root           3       2  0 13:18 ?        00:00:00  \_ [pool_workqueue_release]
root           4       2  0 13:18 ?        00:00:00  \_ [kworker/R-rcu_g]
...
root          33       2  0 13:18 ?        00:00:00  \_ [cpuhp/3]
```

## Итог:
* Все процессы с PPID = 2 являются потомками kthreadd, который сам порожден ядром (PPID = 0).
* Системные потоки ядра: kworker, rcu, migration, cpuhp, и др.
* Дерево показывает иерархию: kthreadd → рабочие потоки ядра.


## Команды:
```
pstree -p | head -n 50 | cat
```

## Вывод:
```
systemd(1)-+-ModemManager(773)-+-{ModemManager}(798)
           |                   `-{ModemManager}(807)
           |-NetworkManager(691)-+-{NetworkManager}(771)
           |                     `-{NetworkManager}(774)
           |-VBoxDRMClient(1807)-+-{VBoxDRMClient}(1824)
           |                     ...
           |-gdm3(2275)-+-gdm-session-wor(2627)-+-gdm-wayland-ses(2663)-+-gnome-session-b(2679)
```


## Итоги:
* Корневой процесс systemd(1) - инициализатор системы.
* Ветка gdm3 → gnome-session → gnome-keyring → bash - пользовательская сессия.



# Пункт 3 (Изучение /proc)

## Получение PID текущей оболочки:
```
echo $$
```

## Результат:
```
3506
```
### Это PID текущего процесса оболочки bash.



## Просмотр командной строки запуска:
```
cat /proc/3506/cmdline | tr '\0' ' '; echo
```

## Результат:
```
bash
```

### Файл cmdline содержит команду, с которой был запущен процесс. В данном случае - это bash. Символы \0 заменяются на пробелы для читаемости.


## Просмотр статуса процесса

```
head -n 20 /proc/3506/status
```

## Результат:
```
Name:   bash
Umask:  0002
State:  S (sleeping)
Tgid:   3506
Ngid:   0
Pid:    3506
PPid:   3473
TracerPid:  0
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
FDSize: 256
Groups: 4 24 27 30 46 122 135 136 1000 
NStgid: 3506
NSpid:  3506
NSpgid: 3506
NSsid:  3506
Kthread:    0
VmPeak:    14124 kB
VmSize:    14124 kB
VmLck:         0 kB
```
### Файл status содержит подробную информацию о процессе:

```
Name - имя процесса (bash)
State - текущее состояние (S - спящий)
Pid - идентификатор процесса
PPid - идентификатор родителя
Uid и Gid - пользователь и группа
Threads - количество потоков
VmSize, VmPeak - использование виртуальной памяти
```

## Просмотр открытых дескрипторов
```
ls -l /proc/3506/fd
```

## Результат:
```
lrwx------ 1 justli justli 64 вер 21 13:20 0 -> /dev/pts/0
lrwx------ 1 justli justli 64 вер 21 13:20 1 -> /dev/pts/0
lrwx------ 1 justli justli 64 вер 21 13:20 2 -> /dev/pts/0
lrwx------ 1 justli justli 64 вер 21 13:20 255 -> /dev/pts/0
```

### Каталог fd содержит ссылки на все открытые файловые дескрипторы процесса:

* 0 - стандартный ввод (stdin)
* 1 - стандартный вывод (stdout)
* 2 - стандартная ошибка (stderr)
* 255 - дополнительный дескриптор, может быть связан с редактированием командной строки

### Все дескрипторы указывают на /dev/pts/0 — это псевдотерминал, используемый оболочкой.


## Выводы
* /proc/<pid>/cmdline — показывает команду запуска процесса.
* /proc/<pid>/status — содержит системную информацию: состояние, PID, PPID, UID, память и потоки.
* /proc/<pid>/fd/ — отображает все открытые ресурсы, используемые процессом: файлы, терминалы, сокеты.
* /proc — виртуальная файловая система, обновляется в реальном времени и не занимает места на диске.


# Пункт 4 (Анализ процессов (нагрузка CPU/память/IO)):
## Моментальный срез `top` :
```
top -b -n 1 | head -n 20 | cat
```

## Результат:
* Система работает 44 минуты, 1 пользователь.
* Загрузка: load average: 0.22, 0.05, 0.02 — низкая.
* CPU: 97% простаивает (id), 1.5% пользовательские задачи (us), 1.5% системные (sy).
* Память: 2972.6 MiB всего, 92.9 MiB свободно, 973.7 MiB используется, 1906 MiB в буферах.
* Swap почти не используется.

## TOP-5 процессов по CPU:
```
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
```
## Результат:
```
gnome-shell (PID: 2794, PPID: 2637) — 3.5% CPU, время работы: 44:43

gjs (PID: 5866, PPID: 2794) — 2.1% CPU, время работы: 00:25

snapd (PID: 715, PPID: 1) — 0.7% CPU, время работы: 45:08

packagekitd (PID: 2411, PPID: 1) — 0.6% CPU, время работы: 44:50

fprintd (PID: 5842, PPID: 1) — 0.5% CPU, время работы: 00:29
```

### Итого: Наибольшую нагрузку по CPU создаёт gnome-shell, затем gjs — это компоненты графической оболочки GNOME. Остальные — системные службы.


## TOP-5 процессов по памяти
```
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
```

## Результат:
``` 
gnome-shell (PID: 2794, PPID: 2637) — 13.8% памяти, RSS: 421868 KB

snap-store (PID: 3126, PPID: 2637) — 3.6% памяти, RSS: 111188 KB

gsd-xsettings (PID: 3287, PPID: 2637) — 2.5% памяти, RSS: 78552 KB

evolution-alarm (PID: 3086, PPID: 2768) — 2.1% памяти, RSS: 64772 KB

Xwayland (PID: 3133, PPID: 2794) — 2.0% памяти, RSS: 63328 KB
```
### Итого: gnome-shell также лидирует по памяти. snap-store и gsd-xsettings — графические и фоновые службы GNOME.


## Средняя нагрузка за 5 секунд (pidstat):
```
pidstat -u -r -d 1 5 | cat
```
## Результат:
### CPU:

* gnome-shell: 4.18% в среднем

* pidstat: 1.20%

* gnome-terminal-: 0.40%

### Memory:

* gnome-shell: 13.86% (421 MiB)

* gnome-terminal-: 1.75% (53 MiB)

* pidstat: 0.14% (4 MiB)

### IO:

* Все процессы показали нулевую активность по kB_rd/s и kB_wr/s - IO-нагрузка отсутствует.

## Выводы: 

* Наибольшую нагрузку на CPU и память создаёт gnome-shell - графическая оболочка GNOME.

* Фоновые службы, такие как snap-store, gsd-xsettings, packagekitd, также потребляют ресурсы, но умеренно.

* IO-нагрузка отсутствует, что типично для системы в состоянии простоя.

* Система работает стабильно, большинство процессов находятся в состоянии S (sleeping).



# Пункт 5 (Мини-утилита ptree)

## Исходный код
```
import os

def get_process_info(pid):
    try:
        with open(f"/proc/{pid}/status") as f:
            name = None
            ppid = None
            for line in f:
                if line.startswith("Name:"):
                    name = line.split()[1]
                elif line.startswith("PPid:"):
                    ppid = int(line.split()[1])
        return name, ppid
    except FileNotFoundError:
        return None, None

def main():
    pid = os.getpid()
    chain = []

    while pid != 0:
        name, ppid = get_process_info(pid)
        if name is None:
            break
        chain.append(f"{name}({pid})")
        pid = ppid

    print(" ← ".join(chain))

if __name__ == "__main__":
    main()
```




## Команда запуска
```
python3 ptree.py
```

## Результат выполнения
```
python3(6125) ← bash(3506) ← gnome-terminal-(3473) ← systemd(2637) ← systemd(1)
```

## Выводы
* Утилита корректно построила цепочку родительских процессов.

* Каждый процесс получен из /proc/<pid>/status, поле Name и PPid.

* Цепочка начинается с python3, в котором запущена утилита, и заканчивается на systemd(1) - корневой процесс системы.

* Утилита демонстрирует, как процессы связаны между собой и как Linux отслеживает их иерархию.


# Ответы на теоретические вопросы

* 1. Чем процесс отличается от программы? Программа - это статический набор инструкций. Процесс - это выполняющийся экземпляр программы с собственным PID, памятью, дескрипторами и контекстом исполнения.

* 2. Что будет, если вызвать fork() без wait()? Дочерний процесс завершится, но его статус останется необработанным. Это приведёт к появлению зомби-процесса, который исчезнет только после вызова wait() или завершения родителя.

* 3. Как система хранит информацию о процессах? Через виртуальную файловую систему `/proc`. Например: `/proc/<pid>/cmdline` - команда запуска, `/proc/<pid>/status` - имя, PID, PPID, UID, состояние, `/proc/<pid>/fd/` - открытые дескрипторы

* 4. Что делает exec() и зачем он нужен? Заменяет текущий образ процесса новым. Используется после fork(), чтобы дочерний процесс запустил другую программу.

* 5. Почему в /proc нет «настоящих» файлов? `/proc` — виртуальная файловая система, создаваемая ядром в реальном времени. Она не занимает места на диске и отображает текущее состояние процессов.

* 6. Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+? `%CPU` — процент использования CPU, `%MEM` — процент использования RAM, `VIRT` — виртуальная память, `RES` — физическая память, `SHR` — общая память, `TIME+` — общее время работы на CPU

* 7. Почему сумма %CPU может быть больше 100%? На многоядерных системах каждое ядро — это 100%. Если процесс использует 2 ядра, его %CPU может быть >100%.

* 8. Чем отличается мгновенное %CPU от load average? Что означает строка Cpu(s) в top (в т.ч. wa)? `%CPU` — текущая активность процесса, `load average` — среднее количество активных процессов за 1, 5 и 15 минут,  `Cpu(s)`: `us` — пользовательские процессы , `sy` — системные , `id` — простаивающие , `wa` — ожидание IO

* 9. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть? CPU — вычисления, IO — операции чтения/записи; Посмотреть можно через: `pidstat -d`, `iotop`, `/proc/<pid>/io`

* 10. Что такое nice/приоритеты процессов и как они влияют на планирование? `nice` — значение приоритета. Чем выше `nice`, тем ниже приоритет. Планировщик CPU отдаёт предпочтение процессам с меньшим `nice`.

* 11. Чем поток отличается от процесса и как увидеть потоки в ps/top? Поток — легковесный процесс, разделяет память с другими потоками. В `ps` — ключ `-L`, в `top` — клавиша `H`.

* 12. Что такое зомби и сироты, как они возникают и куда «деваются»? Зомби — завершившиеся процессы, чьи статусы не считаны родителем. Сироты — процессы, чьи родители завершились. Зомби исчезают после вызова `wait()`. Сироты переназначаются на `systemd(1)` и продолжают работу.
