### Окружение
```
Arch linux x86_64
shell: fish 4.0.2
```
### Цель
Целью данной работы является ознакомление с процессами в Unix подобных системах, а так же наглядно посмотреть как запускаются, работают и записываются программы.

### Шаги
Для выполнения поставленной цели нам предложили задания. Сейчас я рассмотрю шаги для решения данных.
#### 1. 
Для создания родительского процесса и создания двух дочерних я написал программу на C которая запускает эти самые процессы.
```с
#include<stdio.h>
#include <unistd.h>   
#include <sys/wait.h> 

int main() {
    printf("Родительский процесс (PID: %d) запущен.\n",getpid());

    pid_t first_child = fork();

    if (first_child == 0) {
        printf("    Первый дочерний (PID: %d)\n",getpid());
        sleep(1000);
        return 0;
    }else if(first_child == -1){
        printf("Возникла ошибка дочерний процесс 1 не запустился");
        return 1;
    }

    
    pid_t second_child = fork();

    if (second_child == 0) {
        printf("    Второй дочерний (PID: %d)\n",getpid());
        sleep(1000); // Имитация работы
        return 0;
    }else if(second_child == -1){
        printf("Возникла ошибка дочерний процесс 2 не запустился");
        return 1;
    }

    
    printf("Родитель ожидает завершения дочерних процессов...\n" );

    
    wait(NULL);
    wait(NULL);

    printf("Все дочерние процессы завершены. Родитель (PID %d) завершает работу.\n",getpid());

    return 0;
}
```

Выше приведённый код при запуске его в терминале(после компиляции) выдаёт следующий результат:
```
Родительский процесс (PID: 5972) запущен.
Родитель ожидает завершения дочерних процессов...
    Первый дочерний (PID: 5973)
    Второй дочерний (PID: 5974)
Все дочерние процессы завершены. Родитель (PID 5972) завершает работу.
```

#### 2.
Следующим заданием было исследование дерева процессов.
Первая из предложенных команд не дала мне нужный результат и я не смог найти свой процесс. Поэтому я использовал следующую команду для нахождения.
```
ps -aux | grep a.out
```
Вывод команды:
```
  PID TTY          TIME CMD
  11514 pts/5    00:00:00 a.out
```
Дальше мной было использована следующая команда из примера
Вывод команды:
```
systemd(1)-+-NetworkManager(590)-+-{NetworkManager}(629)
           |                     |-{NetworkManager}(631)
           |                     `-{NetworkManager}(632)
           |-Telegram(7519)-+-{Telegram}(7520)
           |                |-{Telegram}(7521)
           |                |-{Telegram}(7522)
           |                |-{Telegram}(7523)
           |                |-{Telegram}(7524)
           |                |-{Telegram}(7525)
           |                |-{Telegram}(7526)
           |                |-{Telegram}(7528)
           |                |-{Telegram}(7529)
           |                |-{Telegram}(7531)
           |                |-{Telegram}(7534)
           |                |-{Telegram}(7535)
           |                |-{Telegram}(7536)
           |                |-{Telegram}(7537)
           |                |-{Telegram}(7538)
           |                |-{Telegram}(7557)
           |                |-{Telegram}(7576)
           |                |-{Telegram}(7579)
           |                |-{Telegram}(7582)
           |                |-{Telegram}(7583)
           |                |-{Telegram}(7584)
           |                |-{Telegram}(7585)
           |                |-{Telegram}(7586)
           |                |-{Telegram}(7587)
           |                |-{Telegram}(7588)
           |                |-{Telegram}(7589)                                              |                |-{Telegram}(7590)                                              |                |-{Telegram}(7591)                                              |                |-{Telegram}(7592)
           |                |-{Telegram}(7593)
           |                |-{Telegram}(7596)                                              |                |-{Telegram}(7603)
           |                |-{Telegram}(7734)
           |                |-{Telegram}(8307)
           |                |-{Telegram}(8503)
           |                |-{Telegram}(9142)
           |                |-{Telegram}(9217)
           |                |-{Telegram}(9247)
           |                `-{Telegram}(9251)
           |-blueman-applet(963)-+-{blueman-applet}(1072)
           |                     |-{blueman-applet}(1074)
           |                     |-{blueman-applet}(1076)
           |                     `-{blueman-applet}(1077)
           |-blueman-tray(1111)-+-{blueman-tray}(1589)
           |                    |-{blueman-tray}(1590)
           |                    |-{blueman-tray}(1592)
           |                    `-{blueman-tray}(1593)
```
Так как эта команды мне не помогла я использовал другую(Она мне не помогла из-за того, что на одной сессии было довольно много программ запущено)
Можно было просто увеличить число, использовать не 50 а 500 и тогда бы в древе мы увидили родительский процесс и два дочерних, но я решил сделать по-другому.
Я использовал следующую команду:
```
pstree -p 11514(PID моего процесса из прошлой команды)
```

#### 3
Так как фиш не поддерживает команду 
```
echo $$
Я использовал 
echo $fish_pid
Результат:
6092
```
Для выполнения след команды я захотел написать скрипт который спрашивает pid и выводит всю информацию о нём
```bash
#!/bin/bash

read -p "Введите PID процесса " name

echo "Статус процесса"

cat /proc/$name/cmdline | tr '\0' ' '; echo

head -n 20 /proc/$name/status

ls -l /proc/$name/fd
```
Для родительского процесса информация была выведена, а для дочерних нет.
Для родительского вывело его PID, маску и PPID (Было больше информации, но я решил её не выводить сюда)
#### 4
Для выполнения этого задания я написал скрипт для того, чтобы выводить информацию о CPU/Память/IO
```bash
#!/bin/bash

  

echo "=== TOP‑5 по CPU ==="

ps -eo pid,comm,%cpu,etime --sort=-%cpu | head -n 6

  

echo

echo "=== TOP‑5 по памяти ==="

ps -eo pid,comm,%mem,rss --sort=-%mem | \

awk 'NR==1 {printf "%-6s %-20s %-6s %-10s\n", $1,$2,$3,"RSS(MiB)"; next}

NR<=6 {printf "%-6s %-20s %-6s %-10.1f\n", $1,$2,$3,$4/1024}'

  

echo

echo "=== TOP‑5 по IO (rKB/s, wKB/s) ==="

if command -v pidstat >/dev/null; then

pidstat -d 1 1 | \

awk 'NR>3 {print $0}' | sort -k4 -nr | head -n 5

else

echo "pidstat не найден. Установите пакет sysstat."

fi
```
Результат:
```
=== TOP‑5 по CPU ===
    PID COMMAND         %CPU     ELAPSED
  12860 ps               100       00:00
  10201 electron         4.4       50:28
   9564 electron         1.3       55:44
  12713 kworker/u49:2+i  1.2       00:57
   9443 electron         1.0       55:45

=== TOP‑5 по памяти ===
PID    COMMAND              %MEM   RSS(MiB)
1424   Isolated             Web    0.0
966    firefox              4.6    736.3
7519   Telegram             4.6    729.3
648    portmaster-core      3.6    566.7
7922   Isolated             Web    0.0

=== TOP‑5 по IO (rKB/s, wKB/s) ===
Average:      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
Average:     1000       966      0.00    876.00      0.00       0  firefox
Average:     1000       925      0.00      8.00      0.00       0  dconf-service
17:49:37     1000       966      0.00    876.00      0.00       0  firefox
17:49:37     1000       925      0.00      8.00      0.00       0  dconf-service
```
Ответ на вопрос по поводу CPU:
 `ps` - это сам вызов, который в момент замера на долю секунды полностью занял одно ядро — поэтому 100%. В реальности это «всплеск» на момент измерения.
 `Electorne` - это оболочка на базе хромиума. 4.4% говорит о том, что процесс активно что‑то рендерит или обрабатывает (UI, фоновые задачи).
 След это тоже электрон, т.к. он делиться на множество процессов, для того чтобы не напрягать систему.
 `kworker` - это поток ядра, обрабатывающий отложенные задачи драйверов/оборудования. Может появляться в топе при активной работе устройств или драйверов.
 и последний тоже электрон

#### 5
 ```bash
 #!/usr/bin/env bash

  

pid=$$

chain=""

  

while :; do

comm=$(<"/proc/$pid/comm" 2>/dev/null)

  

if [ -z "$chain" ]; then

chain="${comm}(${pid})"

else

chain="${comm}(${pid}) ← ${chain}"

fi

  

if [ "$pid" -le 1 ]; then

break

fi

  

ppid=$(awk '/^PPid:/ {print $2}' "/proc/$pid/status" 2>/dev/null)

if [ -z "$ppid" ] || [ "$ppid" -eq 0 ] || [ "$ppid" -eq "$pid" ]; then

break

fi


pid=$ppid

done

  

echo "$chain"
 ```
 Скрипт.

#### 6
Ответы на вопросы.
1)  Программа - это несколько процессов.(грубо говоря)
2)  Если использовать fork() без wait, то без родителя он станет сиротой и его примет init
3)  Каждый процесс представлен task_struct. Виртуальные файлы можно увидеть в ``/proc/<pid>/``
4)  Заменяет текущий образ процесса новым(загружает программу в то же место)
5)  `proc` - это **виртуальная файловая система**, отображающая состояние ядра и процессов.
6) `%CPU` — доля использования CPU процессом.
 `%MEM` — доля использования оперативной памяти.
 `VIRT` — виртуальная память (включая swap и mmap).
 `RES` — реально используемая физическая память.
`SHR` — общая память, разделяемая с другими процессами.
`TIME+` — суммарное процессорное время процесса.
7) Это было написано в замечании и озвучено на паре. Из-за того, что система многопроцессорная и то, что каждое ядро это 100 процентов
8) `%CPU` — мгновенное использование CPU процессом.
   `load average` — среднее количество активных процессов за 1, 5 и 15 минут.
    Строка `Cpu(s)` показывает распределение загрузки:
    `us` — пользовательские процессы       
    `sy` — системные процессы    
    `wa` — ожидание ввода-вывода
    `id` — простаивающее время
9)  CPU -  активное выполнение
   IO- ожидание операций
   pidstat -d - статистика ввода-вывода по PID
   iotop мониторинг IO в реальном времени
10)  nice - это значение от -20 до 19. Чем ниже nice тем чаще процесс получает CPU
11) Потоки — легковесные процессы, разделяющие память и ресурсы. В `ps` можно использовать `ps -eLf`, в `top` — `H` для отображения потоков.
12) **Зомби** — завершившиеся процессы, чьи статусы не считаны родителем. **Сироты** — процессы, оставшиеся без родителя. Зомби исчезают после `wait()`, сироты усыновляются `init` и продолжают работу.

#### Дополнение
    В работе использовался Deepseek для нахождения информации о командах и уточнения неясностей.
  