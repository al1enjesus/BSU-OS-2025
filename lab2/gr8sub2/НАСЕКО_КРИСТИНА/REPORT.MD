# Лабораторная 2 — Процессы и файловая система /proc
Практика по процессам Linux. В этой работе разберается, что такое процесс, как они создаются, где смотреть информацию о них в /proc, и пишем простые программы.

## Цели
Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc.

Ubuntu 24.04.3 на VirtualBox.

## Задания

1) Создание процессов
Цель: родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

Шаги/решения:
    - Написание программы на С, в которой процесс-родитель вызывает порождение дважды.
    - Сборка и запуск программы с помощью GCC.
    
Код:
    Код представлен в файле fork_example.c, сборка и запуск файла с помощью Makefile.
  
Результат:

    parent: PID=5597
    child_A: PID=5598, PPID=5597
    child_B: PID=5599, PPID=5597
    child exited with code: 0
    child exited with code: 0


Выводы:
   Родительский процесс успешно создает и ожидает завершения двух дочерних процессов. Продемонстрирована иерархия процессов.
    
Использование ИИ:
    Помощь в написании кода на С для fork_example.c, проверка правильности написания Makefile.


2) Исследование дерева процессов
Цель: изучить структуру дерева процессов в системе.

Шаги/решения:
    - Просмотреть дерево процессов двумя способами.
    - Найти свой процесс и родителей.
    - Сравнить информацию, полученную обеими командами. 

Команда:

   ps -ef --forest | head -n 30 | cat


Часть резальтата вывода (первые 3 строки - достаточно для демонстрации):

    UID          PID    PPID  C STIME TTY          TIME CMD
    root           2       0  0 16:22 ?        00:00:00 [kthreadd]
    root           3       2  0 16:22 ?        00:00:00  \_ [pool_workqueue_release]
    root           4       2  0 16:22 ?        00:00:00  \_ [kworker/R-rcu_gp]


Команда:

   pstree -p | head -n 50 | cat
    

Часть результата вывода (первые 6 строк - достаточно для демонстрации):

systemd(1)-+-ModemManager(1386)-+-{ModemManager}(1400)
           |                    |-{ModemManager}(1402)
           |                    `-{ModemManager}(1404)
           |-NetworkManager(1361)-+-{NetworkManager}(1405)
           |                      |-{NetworkManager}(1406)
           |                      `-{NetworkManager}(1407)


Выводы:
    Данные команды позволяют наглядно получить представление иерархии процессов в системе. Первая команда помогает получить более полную информацию о каждом процессе. Вторая же команда помогает лучше понять иерархию процессов, благодаря визуализации в виде дерева. 
    
Использование ИИ:
    Объяснение в различии данных двух команд.


3) Изучение /proc
Цель: 
    Изучить виртуальную файловую систему /proc и научиться извлекать информацию о процессах через их файловые дескрипторы.

Шаги/решения:
    - Узнать PID текущей оболочки.
    - Исследовать содержимое файлов в /proc/<pid>.
    - Проанализировать полученную информацию
    
Команда:

    cat /proc/5554/cmdline | tr '\0' ' '; echo


Результат:

    bash


Команда:

    head -n 20 /proc/5554/status


Результат:

    Name:	bash
    Umask:	0002
    State:	S (sleeping)
    Tgid:	5554
    Ngid:	0
    Pid:	5554
    PPid:	5547
    TracerPid:	0
    Uid:	1000	1000	1000	1000
    Gid:	1000	1000	1000	1000
    FDSize:	256
    Groups:	4 24 27 30 46 100 114 984 1000 
    NStgid:	5554
    NSpid:	5554
    NSpgid:	5554
    NSsid:	5554
    Kthread:	0
    VmPeak:	   19932 kB
    VmSize:	   19932 kB
    VmLck:	       0 kB


Команда:

    ls -l /proc/5554/fd


Результат:

    lrwx------ 1 chris chris 64 сен 20 16:52 0 -> /dev/pts/0
    lrwx------ 1 chris chris 64 сен 20 16:52 1 -> /dev/pts/0
    lrwx------ 1 chris chris 64 сен 20 16:52 2 -> /dev/pts/0
    lrwx------ 1 chris chris 64 сен 20 16:52 255 -> /dev/pts/0
   
    
Выводы:
   Все три комнды работают корректно и выдают ожидаемую информацию. Первая команда позволяет узнать полную командную строку процесса, вторая команда содержит информацию о текущем процессе, а третья - показывает все открытые процессом файлы и сокеты.
    
Использование ИИ:
    Изучение информации о /proc, а также о том, какие именно данные выводит команда получения информации текущего процесса bush.


4)  Анализ процессов (нагрузка CPU/память/IO)
Цель: научиться анализировать живые процессы.

Шаги/решения:
    - Использование команд для анализа процессов.
    - Узнать TOP‑5 по CPU, по памяти и по IO.
    - Анализ полученных данных
    
Команда для TOP‑5 по CPU:

    ps -eo pid,comm,%cpu,etime --sort=-%cpu | head -n 6


Результат:

    PID COMMAND         %CPU     ELAPSED
   2476 gnome-shell      2.2       54:04
   1002 snapd            0.4       54:46
   5547 gnome-terminal-  0.2       42:49
   3216 ibus-extension-  0.1       53:38
   1325 VBoxDRMClient    0.1       54:40


Краткий вывод:
   Основные процессы - это компоненты графической среды и фоновые службы.

Команда для TOP‑5 по памяти:

    ps -eo pid,comm,%mem,rss --sort=-%mem | head -n 6 | awk '
    NR==1 {
        printf "%-8s %-20s %-6s %-10s %-10s\n", $1, $2, $3, $4, "RSS(MiB)"
    }
    NR>1 {
        printf "%-8s %-20s %-6s %-10s %-10.1f\n", $1, $2, $3, $4, $4/1024
    }'


Результат:

    PID      COMMAND              %MEM   RSS        RSS(MiB)  
    2476     gnome-shell          5.6    454892     444,2     
    3765     mutter-x11-fram      1.2    101884     99,5      
    3552     gsd-xsettings        1.0    84212      82,2      
    3341     Xwayland             0.8    71056      69,4      
    3711     gjs                  0.8    65768      64,2   


Краткий вывод:
    Наибольшую нагрузку создает графическая среда GNOME.

Команда для TOP‑5 по IO:

    sudo iotop -b -n 1 -k | head -n 12 | tail -n 5


Результат:

     5 be/0 root        0.00 K/s    0.00 K/s ?unavailable?  [kworker/R-sync_wq]
     6 be/0 root        0.00 K/s    0.00 K/s ?unavailable?  [kworker/R-kvfree_rcu_reclaim]
     7 be/0 root        0.00 K/s    0.00 K/s ?unavailable?  [kworker/R-slub_flushwq]
     8 be/0 root        0.00 K/s    0.00 K/s ?unavailable?  [kworker/R-netns]
    11 be/0 root        0.00 K/s    0.00 K/s ?unavailable?  [kworker/0:0H-events_highpri]


Краткий вывод:
    Система в момент проверки не испытавала значительную нагрузку на подсистему IO.

Выводы:
    Команды для анализа нагрузки на систему успешно выполнены. Система находится в состоянии низкой нагрузки. Основную нагрузку в момент измерения создавали фоновые службы и графическая среда и ее компоненты.
    
Использование ИИ:
    Помощь в написании команд и анализировании вывод этих команд.


5) Мини‑утилита ptree
Цель: написать утилиту, печатающую цепочку родителей от текущего процесса до PID 1 (init/systemd).

Шаги/решения:
    - Написать необходимую программу (на С).
    - Протестировать утилиту.
    
Код:
    Код утилиты предоставлен в файле ptree.c
  
Результат:
    
   ptree(6815) ← bash(6713) ← gnome-terminal-(6705) ← systemd(1637) ← systemd(1)

    
Выводы:
   Успешно создана утилита, которая отображает цепочку родительских процессов. 
    
Использование ИИ:
    Помощь в создании утилиты.


##Ответы на вопросы
1. Программа — это статический набор инструкций, записанный на диске в виде файла, а процесс — это экземпляр программы, который выполняется в операционной системе.
2. Дочерний процесс станет "зомби" - будет присутствовать в таблице процессов ОС, потребляя ее ресурсы и занимая идентификатор процесса, даже если процесс уже не выполняет код.
3. В вирутальной файловой системе /proc, где для каждого запущенного процесса создается подкаталог с его уникальным идентификатором (PID). Эти каталоги содержат множество файлов, предоставляющих детальные данные о состоянии процесса.
4. Заменяет текущий процесс новым, запуская указанную программу или скрипт без создания нового процесса-потомка.
5. В каталоге /proc нет "настоящих" файлов, потому что это виртуальная файловая система, которая не имеет физического расположения на диске.
6. %CPU - процент использования процессорного времени; %MEM - процент использования оперативной памяти; VIRT - общий объем используемой виртуальной памяти; RES - объем физической памяти, используемой процессом; SHR - объем памяти, которая может быть разделена с другими процессами; TIME+ - отображает суммарное время работы процесса с момента его запуска.
7.  В многопроцессорных системах сумма %CPU может быть больше 100%, потому что для каждого отдельного ядра максимальный процент использования это 100%, а т.к. ядер несколько, то получается что максимально возможная сумма %CPU = кол-во процессров * 100%. 
8. %CPU показывает использование CPU в конкретный момент времени, а load average - среднюю нагрузку всей система за три временных интервала: 1, 5 и 15 минут; wa - процент времени, когда процессор ожидал завершения операций ввода-вывода.
9. IO-нагрузка связана с операциями ввода-вывода, а CPU-нагрузка - с использованием процессорного времени. Как увидеть: iostat, iotop.
10. nice/приоритет процесса — это числовая величина (от -20 до 19), определяющая, как часто процессор выделяет процессу процессорное время. Приоритеты помогают планировщику распределить время CPU между процессами.
11. Процесс — это независимая программа с собственным адресным пространством и ресурсами, а поток - разделяет адресное пространство и ресурсы процесса c другими потоками. Команда, чтобы увидеть потоки в ps/top: top -H.
12. Зомби - завершенный процесс, чей родитель еще не вызвал wait() для получения статуса завершения. Сирота - работающий процесс, у которого завершился родитель. Зомби-процесс пересает таковым быть, когда родительский процесс завершают свою работу и вызывает wait(). Сироты - "усыновляются", обычно, процессом init (PID = 1), сирота продолжает работать до своего завершения (init переодически вызывает wait() дл завершения процессов-сирот).


## Итоги
  При выполнении лабораторной работы успешно усвоены команды для анализирования процессов, для просмотра информации о процессах. Было интресено писать программы на С для выполнения лабораторной работы. Закреплены знания о процессах.
