## Лабораторная 2 — Процессы и файловая система /proc

Лабораторная работа для 2‑го курса: практика по процессам Linux. В этой работе разберём, что такое процесс, как они
создаются, где смотреть информацию о них в `/proc`, и напишем простые программы.

## Цель

Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из
`/proc`.

## Ход работы

### 1) Создание процессов

Задача: родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех
дочерних.

Что реализовать:

- Программа на C или Python, в которой процесс‑родитель вызывает порождение дважды.
- Каждый дочерний процесс печатает: `child[i]: PID=<pid>, PPID=<ppid>` (индекс `i` любой: 0/1 или A/B).
- Родитель печатает старт/завершение и ожидает обоих детей (`wait()/waitpid()` или эквивалент в Python) с выводом кода
  завершения.
- Обеспечьте сброс буфера вывода (C: `fflush(stdout)`, Python: `print(..., flush=True)`) чтобы строки не терялись.

Реализуем такую программу на C, исходный код лежит в `src/fork_example.c`.

Для запуска нужно ввести следующую команду

```bash
make run-fork
```

Ожидаем примерно такой вывод:

```
parent: start PID=11152
child[0]: PID=11153, PPID=11152
child[1]: PID=11154, PPID=11152
parent: child[0] pid=11153 exited code=10
parent: child[1] pid=11154 exited code=11
parent: done PID=11152
```

#### Анализ

Запустился родитель с `PID=11152`, он породил двух потомков, у обоих верный родитель. Далее завершились дети с кодами
`10` и `11`, именно те, которые и были заданы намеренно для различия, родитель дождался их и напечатал коды завершения.

### 2) Исследование дерева процессов

Для начала запустим нашу программу:

```bash
make run-fork
```

Лишь через 10 секунд дети завершаются, поэтому пока видим неполный вывод:

```
parent: start PID=13752
child[0]: PID=13753, PPID=13752
child[1]: PID=13754, PPID=13752
```

Далее вводим команду

```bash
ps -eo pid,ppid,comm --sort=-pid | head
```

И ищём наши процессы

```
    PID    PPID COMMAND
  13762   13620 head
  13761   13620 ps
  13760       2 kworker/9:1
  13755    3714 localsearch-ext
  13754   13752 fork_example 
  13753   13752 fork_example
  13752   13751 fork_example
  13751    9472 make
  13708    1288 chrome
```

И тут мы видим все наши созданные процессы, родителя с `PID=13752`, и двух детей с `PID=13753` и `PID=13754`.

Далее посмотрим на процессы в виде дерева, с помощью команды

```bash
pstree -p | cat
```

И там аналогично найдём наши процессы:

```
|-kitty(9458)-+-kitten(9466)-+-{kitten}(9468)
           |             |              |-{kitten}(9469)
           |             |              |-{kitten}(9470)
           |             |              |-{kitten}(9471)
           |             |              |-{kitten}(9473)
           |             |              |-{kitten}(9474)
           |             |              |-{kitten}(9475)
           |             |              |-{kitten}(9476)
           |             |              |-{kitten}(9477)
           |             |              |-{kitten}(9702)
           |             |              |-{kitten}(9949)
           |             |              |-{kitten}(10293)
           |             |              `-{kitten}(11631)
           |             |-zsh(9472)---make(13751)---fork_example(13752)-+-fork_example(13753)
           |             |                                               `-fork_example(13754)
           |             |-{kitty}(9462)
           |             |-{kitty}(9463)
           |             |-{kitty}(9464)
           |             |-{kitty}(9465)
           |             `-{kitty}(9467)
```

#### Использование ИИ

Помощь с сортировкой процессов по убыванию PID.

#### Анализ

С помощью команд `ps` и `pstree`, мы можем действительно увидеть, что наша программа запускает процессы, различия их
лишь в том, как мы видим их, `ps` показывает их в виде таблиц, а `pstree` в виде дерева.

### 3) Изучение /proc

1) Узнаем PID текущей оболочки: `echo $$`

```
13620
```

2) Посмотрим на:

```bash
cat /proc/$$/cmdline | tr '\0' ' '; echo
```

Ожидаем вывод:

```
/usr/bin/zsh 
```

Этот файл показывает командную строку процесса. Аргументы разделены нулевыми байтами , поэтому мы заменяем их на
пробелы.

Далее посмотрим на:

```bash
head -n 20 /proc/$$/status
```

Ожидаем вывод:

```
Name:	zsh
Umask:	0022
State:	S (sleeping)
Tgid:	13620
Ngid:	0
Pid:	13620
PPid:	13610
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	998 1000 
NStgid:	13620
NSpid:	13620
NSpgid:	13620
NSsid:	13620
Kthread:	0
VmPeak:	  11388 kB
VmSize:	  11072 kB
VmLck:	      0 kB
```

Этот файл показывает читаемую сводку о процессе c PID=$$.

Посмотрим на:

```bash
ls -l /proc/$$/fd
```

Ожидаем вывод:

```
total 0
lrwx------ 1 wresq wresq 64 Sep 21 19:46 0 -> /dev/pts/2
lrwx------ 1 wresq wresq 64 Sep 21 20:12 1 -> /dev/pts/2
lrwx------ 1 wresq wresq 64 Sep 21 20:12 10 -> /dev/pts/2
l-wx------ 1 wresq wresq 64 Sep 21 20:12 13 -> /dev/pts/2
lrwx------ 1 wresq wresq 64 Sep 21 20:12 2 -> /dev/pts/2
```

Этот каталог представляет собой список всех открытых файловых дескрипторов текущей оболочки.

### 4) Анализ процессов (нагрузка CPU/память/IO)

1) Снимите моментальный срез «тяжёлых» процессов по CPU и памяти:

```bash
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat
```

2) Посмотрите средние показатели за интервал (CPU/Memory/IO), требуется пакет `sysstat`:

```bash
pidstat -u -r -d 1 5 | cat   # 5 интервалов по 1 сек
```
```
Linux 6.16.7-arch1-1 (archlinux)        09/21/2025      _x86_64_        (32 CPU)

09:58:50 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
09:58:51 PM  1000      1078    4.95    1.98    0.00    0.00    6.93    12  Hyprland
09:58:51 PM  1000      1156    1.98    0.99    0.00    0.00    2.97     0  Xwayland
09:58:51 PM  1000      5287   24.75    5.94    0.00    0.00   30.69     4  clion
09:58:51 PM  1000      5386    0.99    0.00    0.00    0.00    0.99     4  Rider.Backend
09:58:51 PM  1000      5776    0.00    0.99    0.00    0.00    0.99    17  jcef_helper
09:58:51 PM  1000      6891    0.99    0.00    0.00    0.00    0.99    18  Telegram
09:58:51 PM  1000     16057    0.99    0.00    0.00    0.00    0.99     9  jcef_helper
09:58:51 PM     0     20407    0.00    0.99    0.00    0.00    0.99    12  kworker/u129:1-i915_flip
09:58:51 PM     0     20638    0.00    3.96    0.00    0.00    3.96    10  kworker/u128:1-events_unbound
09:58:51 PM  1000     22623    0.00    0.99    0.00    0.00    0.99     8  pidstat
09:58:51 PM  1000     22626    0.99    0.00    0.00    0.00    0.99    10  localsearch-ext
```
Основную CPU нагрузку даёт clion, далее Hyprland и Xwayland. `%wait` у всех ~0, признаков ботлнеков в I/O.
3) По желанию: замер дискового ввода/вывода «тяжёлых» процессов (требуется root):

```bash
sudo iotop -b -n 5 | head -n 30 | cat
```

4) Визуально: можно открыть `htop` и сделать скриншот топа процессов у себя:

```bash
htop -u "$USER"
```

- TOP‑5 по CPU: `PID`, `COMMAND`, `%CPU`, `ETIME`

Команда:
```bash
ps -eo pid,comm,pcpu,etime --sort=-pcpu | head -n 6 | column -t
```
Вывод:
```
PID   COMMAND   %CPU  ELAPSED
5287  clion     8.9   01:51:56
1078  Hyprland  4.2   02:07:56
9123  chrome    3.5   01:37:34
1270  chrome    2.7   02:07:50
1322  chrome    2.4   02:07:50
```

По CPU систему нагружает больше всех clion - это IDE для C/C++. Далее Hyprland - это графическая оболочка, и несколько
процессов chrome.

- TOP‑5 по памяти: `PID`, `COMMAND`, `%MEM`, `RSS (MiB)`.
Команда:
```bash
ps -eo pid,comm,pmem,rss --sort=-pmem | head -n 6 | column -t
```
Вывод:
```
PID   COMMAND        %MEM  RSS
5287  clion          8.2   2682008
6891  Telegram       3.5   1155344
5386  Rider.Backend  1.9   639184
1270  chrome         1.4   477648
9123  chrome         1.3   438124
```

По памяти систему нагружает больше всех опять же clion, затем telegram, Rider.Backend запущенный CLion, это компонент
плагина clion-radler. Далее chrome, но у него суммарный расход выше из-за множества процессов.

#### Выводы

Нагрузка полностью соответствует запущенным программам. Аномалий и убегающих процессов не обнаружено, в топе находятся
IDE и активные вкладки chrome.

### 5) Мини‑утилита ptree

Реализуем утилиту на C, которая будет печатать цепочку родителей от текущего процесса до PID 1. Исходный код находится в
`src/ptree.c`

Для запуска:

```bash
make run-ptree
```

Пример выполнения:

```
ptree(18877) ← make(18872) ← zsh(18825) ← clion(5287) ← systemd(1)
```

#### Вывод

Утилита успешно отобразила цепочку родительских процессов.

## Вопросы для отчёта (обязательно)

1. Чем процесс отличается от программы?

Программа - пассивный файл с кодом на диске, процесс - активное выполнение программы.

2. Что будет, если вызвать `fork()` без `wait()`?

Без `wait()` дочерние процессы после завершения становятся зомби и висят до подбора статуса.

3. Как система хранит информацию о процессах?

Linux хранит информацию о процессах в памяти ядра в структурах task_struct (на поток) и связанных с ней.

4. Что делает `exec()` и зачем он нужен?

Он заменяет текущий процесс другой программой, используется вместе с `fork()` для запуска внешних программ.

5. Почему в `/proc` нет «настоящих» файлов?

`/proc` - виртуальная «файловая»-система, содержимое генерируется ядром при обращении и не хранится на диске

6. Как интерпретировать поля `top`: `%CPU`, `%MEM`, `VIRT`, `RES`, `SHR`, `TIME+`?

`%CPU` — загрузка ядра процессом; `%MEM` — доля RAM ; `VIRT` — всё адресное пространство; `RES` — фактически занятая
RAM; `SHR` — её общая часть; `TIME+` — суммарное CPU-время процесса.

7. Почему сумма `%CPU` может быть больше 100%?

Потому что `%CPU` считается на одно ядро, и поэтому сумма может быть до `100% * #ядер`.

8. Чем отличается мгновенное `%CPU` от `load average`? Что означает строка `Cpu(s)` в `top` (в т.ч. `wa`)?

`%CPU` - текущая доля одного логического ядра за последний интервал, `load average` - среднее числа задач в очереди к CPU +
задачи в состоянии непрерывного ожидания I/O.`Cpu(s)` - разложение времени CPU по категориям за интервал обновления.

- `us` — пользовательский код .
- `sy` — системный код .
- `ni` — пользовательский код с nice приоритетом.
- `id` — простой.
- `wa` — CPU простаивал, пока задачи ждали I/O операции.
- `hi/si` — аппаратные/программные прерывания.
- `st` — CPU был недоступен для текущей виртуальной машины.

9. Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть (`pidstat -d`, `iotop`, `/proc/<pid>/io`)?

CPU-нагрузка -  процесс тратит время на вычисление, IO-нагрузка - процесс ждёт диск/сеть. Видны скорости в `pidstat -d`, топ в `iotop`. Для конкретного PID счётчики I/O в `/proc/<pid>/io`.
10. Что такое `nice`/приоритеты процессов и как они влияют на планирование?

`nice` - «вежливость» обычных процессов, чем меньше `NI`, тем выше приоритет и доля CPU. Влияет на долю CPU среди обычных задач, не гарантирует строгих процентов.
11. Чем поток отличается от процесса и как увидеть потоки в `ps`/`top`?

Процесс - контейнер ресурсов , поток — единица выполнения в процессе, делит память/ресурсы, имеет свой TID и планируется отдельно.
Чтобы посмотреть все потоки можно воспользоваться командой `ps -eLf | head`, для конкретного процесса `ps -T -p <pid>`. Также можно и через `top` , показать потоки - `top -H`, для конкретного процесса - `top -H -p <pid>`.
12. Что такое зомби и сироты, как они возникают и куда «деваются»?

Зомби - завершившийся дочерний процесс, у которого родитель ещё не вызвал wait(), висят как `STAT=Z` до подбора статуса. Сироты - живые дети умершего родителя, их усыновляет `PID=1` и дальше они работают нормально.

## Использование ИИ
Помощь с написанием кода на C и Makefile, с ответами на вопросы.