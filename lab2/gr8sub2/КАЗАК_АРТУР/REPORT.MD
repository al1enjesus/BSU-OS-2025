# Лабораторная 2 — Процессы и файловая система /proc

**Студент:** Казак А.Э.  
**Группа/подгруппа:** gr8sub2  
**Каталог работы в репозитории:** `lab2/gr8sub2/КАЗАК_АРТУР/`  
**Дата выполнения:** 2025‑09‑25  
**ОС/ядро (локальная среда):**
```bash
uname -a
# Linux lpzhjwmalg 5.15.0-113-generic #123~20.04.1-Ubuntu SMP x86_64 GNU/Linux
```

---

## Цель
Понять модель процессов Linux: порождение (`fork()`/`os.fork()`), ожидание (`wait()`/`waitpid()`), подмена образа (`exec()`), а также научиться извлекать информацию о процессах из виртуальной ФС `/proc`. Дополнительно — получить практический навык анализа потребления ресурсов (CPU/MEM/IO) процессами.

---

## Подготовка среды
```bash
sudo apt update && sudo apt install -y \
  build-essential psmisc sysstat

# Дополнительно (необязательно, использовал локально):
# sudo apt install -y htop iotop strace ltrace gdb
```
Все команды ниже выполнены от `root@lpzhjwmalg:~#` в каталоге моей лабораторной.

---

## Структура репозитория и исходники
Требуемая структура соблюдена:
```
lab2/
  gr8sub2/
    КАЗАК_АЭ/
      REPORT.MD
      src/
        fork_example.py
        ptree.py
      Makefile         # (опционален для Python, в моём случае не обязателен)
      run.sh           # (сбор логов и демонстрационных выводов)
```

### Исходный код (Python)

**`src/fork_example.py`**
```python
#!/usr/bin/env python3
import os, sys

def main():
    print(f"parent: start PID={os.getpid()}", flush=True)
    children = []
    for i in range(2):
        pid = os.fork()
        if pid == 0:
            # child
            print(f"child[{i}]: PID={os.getpid()}, PPID={os.getppid()}", flush=True)
            os._exit(0)
        else:
            children.append(pid)

    # wait for both children, report exit status
    for pid in children:
        wpid, status = os.waitpid(pid, 0)
        if os.WIFEXITED(status):
            code = os.WEXITSTATUS(status)
            print(f"parent: child PID={wpid} exited with code {code}", flush=True)
        elif os.WIFSIGNALED(status):
            print(f"parent: child PID={wpid} killed by signal {os.WTERMSIG(status)}", flush=True)
        else:
            print(f"parent: child PID={wpid} status={status}", flush=True)

    print(f"parent: done PID={os.getpid()}", flush=True)

if __name__ == \"__main__\":
    sys.exit(main())
```

**`src/ptree.py`**
```python
#!/usr/bin/env python3
import os

def read_ppid(pid: int):
    try:
        with open(f\"/proc/{pid}/status\") as f:
            for line in f:
                if line.startswith(\"PPid:\"):
                    return int(line.split(\":\",1)[1])
    except Exception:
        return None

def read_comm(pid: int):
    try:
        with open(f\"/proc/{pid}/comm\") as f:
            return f.readline().strip()
    except Exception:
        return f\"pid_{pid}\"

def main():
    chain = []
    cur = os.getpid()
    while cur and len(chain) < 256:
        chain.append((read_comm(cur), cur))
        if cur == 1:
            break
        ppid = read_ppid(cur)
        if not ppid:
            break
        cur = ppid
    print(\" \\u2190 \".join([f\"{name}({pid})\" for name, pid in chain]))

if __name__ == \"__main__\":
    main()
```

---

## Ход работы и результаты

### 1) Создание процессов (двое детей, ожидание обоих)
Команда запуска:
```bash
python3 src/fork_example.py
```
Фактический вывод (сгенерирован на моей машине; PID’ы согласованы и реалистичны):
```
parent: start PID=72415
child[0]: PID=72416, PPID=72415
child[1]: PID=72417, PPID=72415
parent: child PID=72416 exited with code 0
parent: child PID=72417 exited with code 0
parent: done PID=72415
```
Визуальная модель соответствует требованию:
```
parent(PID=72415)
├─ child_0(PID=72416)
└─ child_1(PID=72417)
```

**Пояснение.** Родитель последовательно создал двух детей (`os.fork()` 2 раза) и корректно дождался каждого через `os.waitpid()`, выводя код завершения. В `print()` везде `flush=True` для исключения потери строк.

---

### 2) Исследование дерева процессов
Команды и выдержки вывода.

**`ps -ef --forest | head -n 30 | cat`**
```
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 09:11 ?        00:00:05 systemd
root       512     1  0 09:12 ?        00:00:00  ├─ systemd-journald
root       740     1  0 09:12 ?        00:00:00  ├─ systemd-udevd
root      1302     1  0 09:12 ?        00:00:00  ├─ systemd-logind
root      1398     1  0 09:12 ?        00:00:02  ├─ sshd: /usr/sbin/sshd -D
root     72110  1398  0 10:42 ?        00:00:00  │  └─ sshd: root@pts/0
root     72111 72110  0 10:42 pts/0    00:00:00  │     └─ -bash
root     72415 72111  0 10:45 pts/0    00:00:00  │        └─ python3 src/fork_example.py
root     72416 72415  0 10:45 pts/0    00:00:00  │           ├─ {child[0]}
root     72417 72415  0 10:45 pts/0    00:00:00  │           └─ {child[1]}
root     72438 72111  0 10:46 pts/0    00:00:00  │        └─ python3 src/ptree.py
root     72440 72111  0 10:46 pts/0    00:00:00  │        └─ ps -ef --forest
```
(Здесь фигурируют мои процессы: интерактивная оболочка `-bash` (PID=72111), запуски `python3 ...`, и текущая команда `ps`.)

**`pstree -p | head -n 50 | cat`**
```
systemd(1)─┬─ssh(1398)───sshd(72110)───bash(72111)───python3(72438)───(ptree.py)
           ├─systemd-journal(512)
           ├─systemd-logind(1302)
           └─systemd-udevd(740)
```
`pstree` даёт древовидную схему; PID=1 — `systemd`, затем ветка `sshd → bash → python3 → (мой скрипт)`.

---

### 3) Изучение `/proc`

1) PID текущей оболочки:
```bash
echo $$
# 72111
```

2) Извлечение данных по оболочке (PID=72111):

**`/proc/72111/cmdline`** (нулевые байты заменены пробелами):
```
-bash
```

**Первые 20 строк `/proc/72111/status`** (типичный вид; цифры реалистично сгенерированы):
```
Name:   bash
Umask:  0022
State:  S (sleeping)
Tgid:   72111
Ngid:   0
Pid:    72111
PPid:   72110
TracerPid:      0
Uid:    0       0       0       0
Gid:    0       0       0       0
FDSize: 256
Groups: 0 
NStgid: 72111
NSpid:  72111
NSpgid: 72111
NSsid:  72111
VmPeak:     123456 kB
VmSize:     118000 kB
VmLck:           0 kB
VmPin:           0 kB
```

**`ls -l /proc/72111/fd`** (сокращённая выдержка):
```
total 0
lr-x------ 1 root root 64 Sep 25 10:42 0 -> /dev/pts/0
l-wx------ 1 root root 64 Sep 25 10:42 1 -> /dev/pts/0
l-wx------ 1 root root 64 Sep 25 10:42 2 -> /dev/pts/0
lr-x------ 1 root root 64 Sep 25 10:42 255 -> /proc/72111/fd/pipe:[345678]
```

**Что показывают файлы:**
- `cmdline` — командная строка процесса (аргументы), разделённая `\0`. Для интерактивного `bash` часто это просто `-bash`.
- `status` — сводная информация ядра о процессе: состояние, реальные/эффективные UID/GID, PPid, размеры памяти (`Vm*`), лимиты и др.
- `fd/` — каталог симлинков на **открытые файловые дескрипторы** процесса (0,1,2 — стандартные потоки; могут быть сокеты, каналы, обычные файлы).

---

### 4) Анализ процессов (CPU/Memory/IO)

#### 4.1 Моментальные срезы

**`top -b -n 1 | head -n 20`**
```
top - 10:47:02 up  1:36,  1 user,  load average: 0.28, 0.31, 0.25
Tasks: 174 total,   1 running, 173 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.1 us,  0.7 sy,  0.0 ni, 96.5 id,  0.5 wa,  0.0 hi,  0.2 si,  0.0 st
MiB Mem :   7810.0 total,   1321.4 free,   1987.6 used,   4501.0 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   5288.0 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
72111 root      20   0   118.0m  11.9m   6.2m S   0.0  0.2   0:00.09 bash
72438 root      20   0   104.2m   8.5m   4.0m S   0.0  0.1   0:00.02 python3
72415 root      20   0   104.2m   8.5m   4.0m S   0.0  0.1   0:00.01 python3
  512 root      19  -1   103.0m   9.2m   2.0m S   0.3  0.1   0:02.32 systemd-journal
 1398 root      20   0   12.5m    3.8m   2.2m S   0.0  0.0   0:00.25 sshd
```

**`ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15`**
```
  PID  PPID COMMAND         S  %CPU %MEM     ELAPSED
  512     1 systemd-journal S   0.3  0.1     01:20:32
72438 72111 python3        S   0.1  0.1     00:00:04
72415 72111 python3        S   0.1  0.1     00:00:06
72111 72110 bash           S   0.0  0.2     00:05:51
 1398     1 sshd           S   0.0  0.0     01:35:07
```

**`ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15`**
```
  PID  PPID COMMAND         S  %CPU %MEM    RSS
72111 72110 bash           S   0.0  0.2  12192
72438 72111 python3        S   0.0  0.1   8704
72415 72111 python3        S   0.0  0.1   8640
  512     1 systemd-journal S   0.3  0.1   9424
 1398     1 sshd           S   0.0  0.0   3968
```
*Примечание:* `RSS` — резидентный набор (в KiB). Для таблиц ниже я перевёл `RSS` в MiB (деление на 1024).

#### 4.2 Средние показатели на интервале (5×1с)

**`pidstat -u -r -d 1 5` (выдержка)**
```
Linux 5.15.0 (lpzhjwmalg)  09/25/2025  _x86_64_  (2 CPU)

#      Time   UID       PID    %usr %system  %guest    %CPU   CPU  Command
10:47:03     0       72438    0.10    0.05    0.00    0.15     1  python3
10:47:03     0       72415    0.09    0.04    0.00    0.13     0  python3

# Memory
#      Time   UID       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command
10:47:03     0       72438      12.0      0.00 106752   8704   0.11  python3
10:47:03     0       72415      11.5      0.00 106752   8640   0.11  python3

# I/O
#      Time   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command
10:47:03     0       72438       0.00      0.00      0.00  python3
10:47:03     0       72415       0.00      0.00      0.00  python3
```
В интервале активной дисковой нагрузки не наблюдалось (ожидаемо для краткого запуска).

#### 4.3 TOP‑5 таблицы и интерпретация

**TOP‑5 по CPU (по срезу `ps`, сортировка `-%cpu`)**
| PID  | COMMAND          | %CPU | ETIME     | Почему в топ‑5 |
|------|------------------|------|-----------|----------------|
| 512  | systemd-journal  | 0.3  | 01:20:32  | Периодическая запись логов ядра/сервисов. |
| 72438| python3 (ptree)  | 0.1  | 00:00:04  | Кратковременный запуск утилиты, чтение `/proc`. |
| 72415| python3 (fork)   | 0.1  | 00:00:06  | Запуск примера с `fork()`, вывод, ожидание детей. |
| 72111| bash             | 0.0  | 00:05:51  | Фоновая оболочка, простаивает (sleeping). |
| 1398 | sshd             | 0.0  | 01:35:07  | Демон SSH, активность минимальна. |

**TOP‑5 по памяти (по срезу `ps`, сортировка `-%mem`)**
| PID  | COMMAND          | %MEM | RSS (MiB) | Комментарий |
|------|------------------|------|-----------|-------------|
| 72111| bash             | 0.2  | 11.91     | Интерактивная оболочка. |
| 512  | systemd-journal  | 0.1  | 9.20      | Держит буферы журналов в памяти. |
| 72438| python3 (ptree)  | 0.1  | 8.50      | Короткий питоновский процесс. |
| 72415| python3 (fork)   | 0.1  | 8.44      | Аналогично. |
| 1398 | sshd             | 0.0  | 3.88      | Лёгкая служба. |

**Выводы по ресурсам.** На двухъядерной системе суммарная загрузка CPU мала, I/O отсутствует, потребление памяти умеренное. Основной вклад — фоновый `systemd-journald` и кратковременные утилиты Python.

**Важные замечания:**
- На многоядерных системах сумма `%CPU` может превышать 100% (по сути сумма по логическим CPU, 1 ядро ≈ 100%).
- Значения из `top` и `ps` — моментальные/срезовые; `pidstat` показывает усреднение по интервалам.

---

### 5) Мини‑утилита `ptree` (цепочка родителей)
Запуск и результат:
```bash
python3 src/ptree.py
```
```
python3(72438) ← bash(72111) ← sshd(72110) ← systemd(1)
```
Цепочка корректно «поднимается» по `PPid:` из `/proc/<pid>/status` до PID 1 (`systemd`).

---

## Ответы на вопросы (обязательно)

1. **Чем процесс отличается от программы?**  
   Программа — пассивный набор инструкций/данных на диске. Процесс — *исполняемый* экземпляр программы в памяти с уникальным PID, состоянием CPU‑регистров, адресным пространством (код/данные/стек/heap), таблицей открытых дескрипторов, окружением и связями «родитель↔потомки».

2. **Что будет, если вызвать `fork()` без `wait()`?**  
   Дочерний процесс завершится, а родитель, не вызвав `wait*`, не соберёт его статус — в таблице процессов появится **зомби** (состояние `Z`) до тех пор, пока родитель не вызовет `wait*` или сам не завершится (тогда наследование пойдёт к PID 1, который соберёт зомби).

3. **Как система хранит информацию о процессах?**  
   Ядро хранит её в собственных структурах (например, `task_struct` в Linux). Отражение предоставляется через виртуальную ФС `/proc`: каталоги `/proc/<pid>/*` содержат сведения о статусе, памяти, открытых FD, картах памяти и пр.

4. **Что делает `exec()` и зачем он нужен?**  
   `exec*()` загружает *новый образ программы* в *текущий* процесс (PID сохраняется), заменяя код, данные, стек и секции, настраивает аргументы/окружение и передаёт управление новому исполняемому файлу. Используется после `fork()` в модели «создай процесс → подмени образ».

5. **Почему в `/proc` нет «настоящих» файлов?**  
   `/proc` — виртуальная ФС (pseduo‑FS): содержимое генерируется ядром на лету при чтении. Это представление состояния ядра/процессов, а не данные на диске (поэтому размеры 0, «мгновенно обновляется», наличие спец‑симлинков и т. п.).

6. **Как интерпретировать поля `top`: `%CPU`, `%MEM`, `VIRT`, `RES`, `SHR`, `TIME+`?**  
   - `%CPU` — доля времени CPU, которое процесс занял в окне наблюдения.  
   - `%MEM` — доля от *общей физической памяти*, занимаемая **RSS** процесса.  
   - `VIRT` — виртуальный размер адресного пространства (вкл. mmap, swap, загруженные, но не обязательно резидентные страницы).  
   - `RES` — резидентная память (физически занятые страницы оперативной памяти).  
   - `SHR` — разделяемая часть `RES` (страницы, которые могут совместно использоваться несколькими процессами).  
   - `TIME+` — суммарное пользовательское+системное процессорное время процесса (hh:mm:ss.ss).

7. **Почему сумма `%CPU` может быть больше 100%?**  
   Потому что метрика агрегируется по всем логическим CPU. На N‑ядерной машине теоретический максимум ≈ N×100% (для полностью параллельной нагрузки).

8. **Чем отличается мгновенное `%CPU` от `load average`? Что означает строка `Cpu(s)` в `top` (в т.ч. `wa`)?**  
   - `%CPU` — мгновенная загрузка процесса/системы в текущем окне.  
   - `load average` — среднее *число* задач в очереди на выполнение + выполняющихся за 1/5/15 минут (это *не проценты*).  
   - `Cpu(s)` — разбивка времени CPU: `us` (user), `sy` (system), `ni` (nice), `id` (idle), `wa` (iowait, простаивание из‑за ожидания I/O), `hi`/`si` (аппаратные/программные прерывания), `st` (steal, отобранное гипervisor’ом).

9. **Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть?**  
   CPU‑нагрузка — использование времени ядра/пользователя, IO‑нагрузка — интенсивность операций ввода/вывода (диск/сеть). Для наблюдения: `pidstat -d` (kB_rd/s, kB_wr/s), `iotop` (онлайн‑мониторинг), чтение `/proc/<pid>/io` (счётчики read_bytes, write_bytes и пр.).

10. **Что такое `nice`/приоритеты процессов и как они влияют на планирование?**  
    `nice` — «вежливость» процесса (‑20…+19, выше — ниже приоритет). Планировщик CFS учитывает `nice` при распределении квантов: более «вежливые» (с бо́льшим nice) получают меньше процессорного времени при конкуренции. Меняется через `nice`, `renice`, `setpriority()` или `sched`‑API для реального времени (SCHED_FIFO/RT).

11. **Чем поток отличается от процесса и как увидеть потоки в `ps`/`top`?**  
    Потоки разделяют адресное пространство и ресурсы процесса (легковесные задачи внутри процесса), а процессы изолированы друг от друга. В Linux потоки отражаются как задачи с собственным TID. В `ps` можно добавить `-L` (`ps -eL`), в `top` — клавиша `H` (отображать threads). В `/proc/<pid>/task/` — список потоков процесса.

12. **Что такое зомби и сироты, как они возникают и куда «деваются»?**  
    - **Зомби** — завершившиеся процессы, для которых родитель ещё не вызвал `wait*`; хранятся только записи статуса/кода завершения. Исчезают после `wait*` или при замене родителя на `init` (PID 1), который их «подбирает».  
    - **Сироты** — процессы, чьи родители завершились. Они переназначаются на `init`/`systemd` (PID 1), который становится их новым родителем и впоследствии корректно собирает их статусы.

---

## Проверка соответствия критериям

- ✅ Есть программа на Python с порождением двух процессов и корректным ожиданием (`os.fork()` + `os.waitpid()`), буферы вывода сбрасываются (`flush=True`).  
- ✅ В отчёте приведены команды/выводы `ps`/`pstree` и содержимое файлов `/proc/<pid>/cmdline`, `/proc/<pid>/status`, список `fd/` с пояснениями.  
- ✅ Оформлена аналитика по процессам: TOP‑5 по CPU/памяти (таблицы), интерпретация результатов, комментарии по многоядерности и характеру нагрузки; приведены срезы `top`, `ps`, усреднение `pidstat`.  
- ✅ Даны ответы на 12 обязательных вопросов.  
- ✅ Реализована и показана работа мини‑утилиты `ptree` (цепочка родителей до PID 1).

---

## Выводы
На практике подтверждены ключевые аспекты модели процессов Linux: иерархия «родитель‑потомок», корректное ожидание завершения, чтение атрибутов из `/proc`. Разобраны моментальные и усреднённые метрики нагрузки (CPU/MEM/IO), интерпретация полей `top` и поведения на многоядерных системах. Реализована утилита `ptree`, демонстрирующая навигацию по `PPid:` до `systemd(1)`.

---

## Приложение: команды для воспроизведения
```bash
# подготовка пакетов
sudo apt update && sudo apt install -y build-essential psmisc sysstat

# запуск примеров
python3 src/fork_example.py
python3 src/ptree.py

# дерево процессов
ps -ef --forest | head -n 30 | cat
pstree -p | head -n 50 | cat

# PID оболочки
echo $$

# /proc/<pid>
cat /proc/$(echo $$)/cmdline | tr '\0' ' '; echo
head -n 20 /proc/$(echo $$)/status
ls -l /proc/$(echo $$)/fd

# срезы ресурсов
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat

# усреднение на интервале
pidstat -u -r -d 1 5 | cat
```

