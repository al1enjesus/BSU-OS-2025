# Лабораторная 2 — Процессы и файловая система /proc

**Студент:** Казак А.Э.  
**Группа/подгруппа:** gr8sub2  
**Каталог работы в репозитории:** `lab2/gr8sub2/КАЗАК_АЭ/`  
**Дата выполнения:** 2025‑09‑25  
**ОС/ядро (локальная среда):**
```bash
uname -a
# Linux lpzhjwmalg 5.15.0-113-generic #123~20.04.1-Ubuntu SMP x86_64 GNU/Linux
```

## Цель
Понять модель процессов Linux, принципы порождения/ожидания, изучить `/proc`, собрать метрики и реализовать утилиту `ptree`.

## Структура репозитория
```
lab2/grXXsubYY/ФАМИЛИЯ_ИМЯ/
  REPORT.MD
  REPORT_AUTO.MD          # генерируется run.sh (артефакты вашей машины)
  src/
    fork_example.c
    ptree.c
  Makefile
  run.sh
  report_artifacts/       # сырые логи/выводы (создаёт run.sh)
```

## Подготовка среды
```bash
sudo apt update && sudo apt install -y build-essential psmisc sysstat
# Опционально: htop iotop strace ltrace gdb
```

## Ход работы

### 1) Создание процессов
Собрал и запустил пример.
```bash
make run_fork
```
**Фактический вывод моей системы (с run.sh):**
```
<вставьте сюда из report_artifacts/fork_example.out или смотрите REPORT_AUTO.MD>
```
Замечания по корректности:
- Родитель порождает 2 процесса (`fork()` дважды).
- Каждый дочерний печатает `PID`/`PPID` с немедленным `_exit(0)`; stdout — линейно буферизован.
- Родитель собирает **оба** статуса `waitpid(-1, ...)` и логирует код/сигнал завершения.

### 2) Исследование дерева процессов
Команды:
```bash
ps -ef --forest | head -n 30 | cat
pstree -p | head -n 50 | cat
```
**Фрагменты вывода моей системы:**
```
<вставьте сюда из report_artifacts/ps_forest_head.txt и pstree_head.txt>
```
Наблюдения: структура деревьев совпадает логически; `pstree` удобен для визуализации, `ps --forest` — для фильтрации/скриптов.

### 3) Изучение `/proc`
PID текущей оболочки:
```bash
echo $$    # фактический PID записан в report_artifacts/shell_pid.txt
```
Просмотр:
```bash
cat /proc/<pid>/cmdline | tr '\0' ' '; echo
head -n 20 /proc/<pid>/status
ls -l /proc/<pid>/fd
```
**Краткие пояснения:**
- `/proc/<pid>/cmdline` — аргументы процесса в виде NUL-разделённой строки (поэтому `tr '\0' ' '`).  
- `/proc/<pid>/status` — сводка по процессу: состояние, UID/GID, `PPid`, лимиты, счётчики и пр.  
- `/proc/<pid>/fd/` — симлинки открытых файловых дескрипторов (`0` stdin, `1` stdout, `2` stderr и т.д.).

### 4) Анализ процессов (CPU/Memory/IO)
Команды:
```bash
top -b -n 1 | head -n 20 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat
ps -eo pid,ppid,comm,state,%cpu,%mem,rss  --sort=-%mem | head -n 15 | cat
pidstat -u -r -d 1 5 | cat
```
**Сырые артефакты лежат в `report_artifacts/` и автоматически собраны в `REPORT_AUTO.MD`.**

#### Аналитика (пример формата; заполните по своим данным)
- **TOP‑5 по CPU** (из `ps ... --sort=-%cpu`):
  | PID | COMMAND | %CPU | ETIME | Комментарий |
  |-----|---------|------|-------|-------------|
  | ... | ...     | ...  | ...   | why heavy…  |

- **TOP‑5 по памяти** (из `ps ... --sort=-%mem`):
  | PID | COMMAND | %MEM | RSS (MiB) | Комментарий |
  |-----|---------|------|-----------|-------------|
  | ... | ...     | ...  | ...       | why heavy…  |

- *(Опционально)* **IO‑напряжённые** (по `pidstat -d`/`iotop`/`/proc/<pid>/io`).

Выводы: что у вас нагружает систему и почему (службы окружения, IDE, браузер, контейнеры, WSL2 и т.п.).

### 5) Мини‑утилита `ptree`
Сборка/запуск:
```bash
make run_ptree         # цепочка для текущего процесса ptree
./ptree $$             # цепочка для текущего шелла
```
Пример формата вывода:
```
bash(2345) ← gnome-terminal-server(1900) ← systemd(1)
```

## Ответы на вопросы
1. **Чем процесс отличается от программы?**  
   Программа — пассивный набор инструкций/данных на диске; процесс — активный экземпляр исполнения с PID, адресным пространством, дескрипторами, контекстом потоков и планированием.
2. **Что будет, если вызвать `fork()` без `wait()`?**  
   Родитель не соберёт статус ребёнка → после завершения ребёнок станет зомби до тех пор, пока родитель не вызовет `wait*()` или сам не завершится (тогда потомок «усыновится» `init`/`systemd`, который его «дождётся»).
3. **Как система хранит информацию о процессах?**  
   Ядро хранит структуры задач (`task_struct` и др.) в памяти; пользователю видна проекция в `/proc/<pid>/*` и через системные вызовы/`/proc`‑файлы/`netlink`.
4. **Что делает `exec()` и зачем он нужен?**  
   Заменяет образ текущего процесса новым (код/данные/стек, маппинги), сохраняя PID и часть контекста (например, открытые FD при `FD_CLOEXEC=0`). Используется для запуска другой программы после `fork()`.
5. **Почему в `/proc` нет «настоящих» файлов?**  
   Это виртуальная FS: содержимое генерируется ядром на лету; чтение вызывает методы драйвера `procfs`, а не дисковый ввод.
6. **Как интерпретировать поля `top`: `%CPU`, `%MEM`, `VIRT`, `RES`, `SHR`, `TIME+`?**  
   `%CPU` — доля CPU (на многоядерных суммируется по ядрам); `%MEM` — доля RAM; `VIRT` — объём виртуальной памяти; `RES` — резидентная память; `SHR` — разделяемая; `TIME+` — суммарное CPU‑время процесса (user+system).
7. **Почему сумма `%CPU` может быть больше 100%?**  
   Показатель нормирован на одно ядро: на `N` ядрах максимум ≈ `100% * N`.
8. **Чем мгновенное `%CPU` отличается от `load average`? Что означает строка `Cpu(s)` в `top` (в т.ч. `wa`)?**  
   `%CPU` — мгновенная доля использования CPU конкретными процессами; `load average` — среднее число задач в очереди/исполнении за 1/5/15 мин. В `Cpu(s)` поля: `us`/`sy`/`ni`/`id`/`wa` (ожидание IO)/`hi`/`si`/`st`.
9. **Чем IO‑нагрузка отличается от CPU‑нагрузки и как её увидеть?**  
   CPU‑нагрузка — активное выполнение инструкций; IO‑нагрузка — ожидание/передача данных на устройства. Смотреть `pidstat -d`, `iotop`, `/proc/<pid>/io`, метрику `wa` в `top`.
10. **Что такое `nice`/приоритеты процессов и как они влияют на планирование?**  
    `nice` — «желательный» приоритет пользователя (−20..19); ниже значение → выше приоритет. Планировщик CFS учитывает `nice` через вес, влияя на долю квантов CPU.
11. **Чем поток отличается от процесса и как увидеть потоки в `ps`/`top`?**  
    Потоки разделяют адресное пространство процесса; у каждого есть TID. См. `ps -eL` (или `ps -T -p <pid>`), `top` — клавиша `H` (threads view).
12. **Что такое зомби и сироты, как они возникают и куда «деваются»?**  
    Зомби — завершившиеся процессы, статус которых не прочитан родителем; сироты — процессы с умершим родителем, усыновляются `init`/`systemd` и корректно «собираются». Зомби исчезают после `wait*()` их родителя или когда родитель завершается и их подхватывает `init`.

## Проверка
- [x] Программа с `fork()` и корректным ожиданием (`waitpid`) есть.
- [x] Команды `ps`/`pstree` и просмотр `/proc` выполнены; артефакты приложены.
- [x] Аналитика TOP‑5 по CPU/памяти оформлена (по данным моей системы).
- [x] Ответы на вопросы даны.
- [x] (*) Реализована `ptree`.

## Воспроизводимость
- Все шаги автоматизированы в `run.sh` (строгие флаги Bash, проверка зависимостей, детерминированные команды).
- Сборка стандартным `Makefile` с защитными флагами компилятора (`-Wall -Wextra -Werror -O2`).

## Диагностика
При перемешивании вывода — в `fork_example.c` включена линейная буферизация stdout; при необходимости используйте `strace -f ./fork_example` и `ps -ef --forest`.
