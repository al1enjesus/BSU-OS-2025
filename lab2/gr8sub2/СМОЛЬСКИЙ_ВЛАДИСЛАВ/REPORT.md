## **Задание 1 — Создание процессов**
#### Цель
Научиться создавать дочерние процессы в C, управлять их выполнением и корректно ожидать завершения с помощью `fork()` и `wait()`.
#### Шаги решения
1. Создаём родительский процесс.
2. Родитель дважды вызывает `fork()`, чтобы порождать двух дочерних процессов.
3. В дочернем процессе проверяется `pid == 0` → печатаем `Child[i]: PID - <pid>, PPID - <ppid>` и вызываем `exit(0)`, чтобы дочерний не создавал своих детей.
4. Родительский процесс ждёт завершения каждого ребёнка через `wait()`/`waitpid()` и выводит старт/завершение дочерних процессов и код завершения.
5. Буфер stdout сбрасывается (`fflush(stdout)`), чтобы строки не терялись при одновременном выводе нескольких процессов.
#### Ключевые выводы
- Родитель создаёт два дочерних процесса и корректно управляет их завершением.
- Дочерние процессы получают уникальный PID и знают PID родителя.
- Буфер вывода контролируется для корректного отображения сообщений.
#### Ответ
Запуск программы:
```bash
make all && make run_fork
```
Ожидаемый результат:
```
Parent started. PID: 6668

Child[0]: PID - 6669, PPID - 6668
Child[1]: PID - 6670, PPID - 6668
Parent: Chlild 6670 finished with code 0
Parent: Chlild 6669 finished with code 0

Parent finished. PID: 6668
```
#### Как проверяли / что было сложным
- Проверка: запуск программы, проверка вывода PID и PPID, проверка, что родитель ждёт завершения обоих детей.
- Сложность: понимание работы функции `fork()` и предотвращение порождения лишних дочерних процессов у ребёнка.
---
## **Задание 2 — Исследование дерева процессов**
#### Цель
Научиться визуализировать дерево процессов в Linux и понимать связи родитель/дочерний процесс.
#### Шаги решения
1. Использовали команду:
    ```bash
    ps -ef --forest | head -n 30 | cat
    ```
    для моментального вывода первых 30 процессов в виде дерева.
2. Сравнили с:
    ```bash
    pstree -p | head -n 50 | cat
    ```
    для компактной графической визуализации дерева с PID.
3. Определили свой процесс и его родителей.
#### Ключевые выводы
- Корневой процесс — `systemd(1)`.
- `ps --forest` полезен для детализации (UID, состояние, время), `pstree` — для наглядной структуры дерева.
#### Как проверяли / что было сложным
- Проверка: поиск текущего PID и его родителей в двух командах, сопоставление дерева.
- Сложность: правильно интерпретировать строки с разными PID и именами процессов.
---
## **Задание 3 — Изучение /proc**
#### Цель
Научиться извлекать информацию о процессе из виртуальной файловой системы `/proc`.
#### Шаги решения

1. Узнали PID текущей оболочки:
    ```bash
    echo $$
    ```
2. Просмотрели командную строку процесса:
    ```bash
    cat /proc/<pid>/cmdline | tr '\0' ' '; echo
    ```
3. Изучили статус процесса (имя, состояние, PID, родитель, UID, память, потоки и др.):
    ```bash
    head -n 20 /proc/<pid>/status
    ```
4. Посмотрели открытые дескрипторы (stdin/stdout/stderr и другие открытые файлы/сокеты):
    ```bash
    ls -l /proc/<pid>/fd
    ```
#### Ключевые выводы
- `/proc/<pid>/cmdline` — аргументы запуска процесса.
- `/proc/<pid>/status` — сводная информация о состоянии процесса.
- `/proc/<pid>/fd` — открытые файловые дескрипторы процесса.
#### Как проверяли / что было сложным
- Проверка: вывод команд для своего PID (bash)
- Сложность: не возникло
---
## **Задание 4 — Анализ процессов (нагрузка CPU/память/IO)**
#### Цель
Проанализировать текущие процессы по нагрузке CPU, памяти и I/O, выявить топ-5 «тяжёлых» процессов.
#### Шаги решения
1. Моментальный снимок ресурсов:
    ```bash
    top -b -n 1 | head -n 20
    ```
2. Списки топ-15 процессов по CPU и памяти:
    ```bash
    ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15
    ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15
    ```
3. Средние показатели за интервал:
    ```bash
    pidstat -u -r -d 1 5
    ```
#### Ключевые выводы
- CPU: основная нагрузка — пользовательская (`%us` ~13%), system load — низкий (0.6).
- Память: активно используется Firefox, вкладки браузера (`Isolated Web Co`) и IDE (`code`).
- I/O: минимальная активность, основная нагрузка — CPU и память.
#### TOP‑5 по CPU
1. `code` - 5.4%
2. `gnome-shell` - 5.2%
3. `firefox` - 5.0%
4. `Isolated Web Co` - 4.4%
5. `code` - 2.0%
#### TOP‑5 по памяти
1. `firefox` - 8.3%
2. `Isolated Web Co` - 5.3%
3. `gnome-shell` - 4.8%
4. `code` - 4.3%
5. `code` - 3.0%
#### Короткие выводы
- Основная нагрузка: Firefox + вкладки (`Isolated Web Co`) и IDE (`code`).
- Системные процессы почти не используют CPU и память.
#### Как проверяли / что было сложным
- Сопоставление PID, COMMAND и ресурсов между `top` и `ps`.
- Анализ динамики через `pidstat` показал изменения нагрузки во времени.
---
## Задание 5 - утилита ptree
#### Цель:
Реализовать утилиту, которая выводит цепочку родителей текущего процесса до процесса `init` (`PID 1`, обычно `systemd`). Освоить работу с файловой системой `/proc` и структурой данных о процессах.
#### Шаги и решения:
1. Изучил содержимое `/proc/<pid>/status`, где хранится информация о процессе.
    - поле `Name:` содержит имя процесса;
    - поле `Pid:` — его PID;
    - поле `PPid:` — идентификатор родительского процесса.
2. Разработал программу на C:
    - получил текущий PID через `getpid()`,
    - в цикле открывал `/proc/<pid>/status`, считывал `Name` и `PPid`,
    - выводил данные в формате `имя(PID) ← родитель(PID)`
3. Использовал функции `fopen()`, `fgets()`, `sscanf()` для чтения файла, `snprintf()` для построения пути `/proc/<pid>/status`.
#### Ключевые выводы:
- У каждого процесса в Linux есть родитель, что позволяет выстраивать цепочку до `init`.
- Файлы `/proc/<pid>/status` содержат всю необходимую информацию о PID и PPID.
#### Ответ
Компиляция и запуск программы:
```bash
make all && make run_ptree
```
Ожидаемый вывод:
```
systemd(1) <- systemd(2148) <- gnome-terminal-(3376) <- bash(3383) <- make(8596) <- ptree(8603)
```
#### Как проверяли / что было сложным:
- Проверка проводилась сравнением результатов программы с `pstree`.
- Основная сложность — корректная работа с файлом `/proc/<pid>/status`.
---
## Вопросы для зачета
1. **Чем процесс отличается от программы?**  
    Программа — это файл с кодом на диске. Процесс — выполняющийся экземпляр программы в памяти с PID и контекстом.
2. **Что будет, если вызвать fork() без wait()?**  
    Дочерние процессы после завершения станут зомби, пока родитель не соберёт их с помощью wait().
3. **Как система хранит информацию о процессах?**  
    В таблице процессов ядра. Доступ к ней пользователь получает через виртуальную ФС (файловую систему) `/proc`.
4. **Что делает exec() и зачем он нужен?**  
    Подменяет текущий образ процесса новым (загружает другую программу в тот же PID). Используется, например, оболочкой для запуска программ.
5. **Почему в /proc нет «настоящих» файлов?**  
    Потому что `/proc` — виртуальная ФС: содержимое формируется ядром при обращении и отображает текущее состояние системы.
6. **Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME+?**
    - `%CPU` — загрузка процессора,
    - `%MEM` — доля оперативной памяти,
    - VIRT — виртуальная память,
    - RES — физическая память,
    - SHR — разделяемая память,
    - TIME+ — процессорное время процесса.
7. **Почему сумма %CPU может быть больше 100%?**  
    Потому что на многоядерных системах загрузка суммируется по ядрам
8. **Чем отличается мгновенное %CPU от load average? Что означает строка Cpu(s) в top (в т.ч. wa)?**
    - %CPU — мгновенная загрузка процессора процессами.
    - Load average — среднее число процессов, ожидающих выполнения за 1/5/15 мин.
    - В `Cpu(s)` wa — время ожидания операций ввода-вывода.
9. **Чем IO-нагрузка отличается от CPU-нагрузки и как её увидеть?**  
    CPU-нагрузка = вычисления, I/O-нагрузка = работа с диском/сетью. Смотреть: `pidstat -d`, `iotop`
10. **Что такое nice/приоритеты процессов и как они влияют на планирование?**  
    Nice — "вежливость" процесса: чем выше, тем ниже приоритет. Влияет на то, как часто процесс получает процессорное время.
11. **Чем поток отличается от процесса и как увидеть потоки в ps/top?**  
    Поток — часть процесса, делит память с другими потоками. Процесс — независимый объект. Потоки видно через `ps -L` или `top -H`.
12. **Что такое зомби и сироты, как они возникают и куда «деваются»?**
    - Зомби — завершившиеся процессы, родитель не вызвал wait(). Убираются после wait().
    - Сироты — процессы, потерявшие родителя; усыновляются `init`/`systemd` и продолжают работу.
---
## Использование ИИ
В ходе выполнения лабораторной работы ИИ применялся для структурирования теоретических сведений о процессах Linux. Объяснялась работа функции `fork()`. Помощь в создании `Makefile`'а