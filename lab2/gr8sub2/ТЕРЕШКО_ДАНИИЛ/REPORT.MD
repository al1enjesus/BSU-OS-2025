# Лабораторная 2 — Процессы и файловая система /proc
  Практика по процессам Linux. В этой работе разберается, что такое процесс, как они создаются, где смотреть информацию о них в /proc, и пишем простые программы.

## Цели
  Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc.

## Среда
  VM Ubuntu 24.04.3 на VirtualBox.

## Задания

### 1) Создание процессов
  **Цель**: родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

**Шаги/решения:**
    1. Написать программу на С, в которой процесс-родитель вызывает порождение дважды.
    2. Собрать и запустить программы с помощью GCC: ```make fork_example && ./fork_example```

**Исходный код:**
  Исходный код программы представлен в src/fork_example.c , а для его сборки используется Makefile

**Результаты:***
```
  parent: PID=3585
  child_A: PID=3586, PPID=3585
  child_B: PID=3587, PPID=3585
```

**Выводы:**
  Родительский процесс успешно создает и ожидает завершения двух дочерних процессов.

### 2) Исследование дерева процессов
  **Цель:** изучить структуру дерева процессов в системе.

**Шаги/решения:**
    1. Просмотреть дерево процессов двумя способами.
    2. Найти свой процесс и родителей.
    3. Сравнить информацию, полученную обеими командами. 

**Команда_1:** 'ps -ef --forest | head -n 30 | cat'

**Результаты:**
```
  UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 06:25 ?        00:00:00 [kthreadd]
root           3       2  0 06:25 ?        00:00:00  \_ [pool_workqueue_release]
root           4       2  0 06:25 ?        00:00:00  \_ [kworker/R-rcu_gp]
root           5       2  0 06:25 ?        00:00:00  \_ [kworker/R-sync_wq]
root           6       2  0 06:25 ?        00:00:00  \_ [kworker/R-kvfree_rcu_reclaim]
root           7       2  0 06:25 ?        00:00:00  \_ [kworker/R-slub_flushwq]
root           8       2  0 06:25 ?        00:00:00  \_ [kworker/R-netns]
root          12       2  0 06:25 ?        00:00:00  \_ [kworker/u16:0-ipv6_addrconf]
root          13       2  0 06:25 ?        00:00:00  \_ [kworker/R-mm_percpu_wq]
root          14       2  0 06:25 ?        00:00:00  \_ [rcu_tasks_kthread]
root          15       2  0 06:25 ?        00:00:00  \_ [rcu_tasks_rude_kthread]
root          16       2  0 06:25 ?        00:00:00  \_ [rcu_tasks_trace_kthread]
root          17       2  0 06:25 ?        00:00:00  \_ [ksoftirqd/0]
root          18       2  0 06:25 ?        00:00:02  \_ [rcu_preempt]
root          19       2  0 06:25 ?        00:00:00  \_ [rcu_exp_par_gp_kthread_worker/0]
root          20       2  0 06:25 ?        00:00:00  \_ [rcu_exp_gp_kthread_worker]
root          21       2  0 06:25 ?        00:00:00  \_ [migration/0]
root          22       2  0 06:25 ?        00:00:00  \_ [idle_inject/0]
root          23       2  0 06:25 ?        00:00:00  \_ [cpuhp/0]
root          24       2  0 06:25 ?        00:00:00  \_ [cpuhp/1]
root          25       2  0 06:25 ?        00:00:00  \_ [idle_inject/1]
root          26       2  0 06:25 ?        00:00:01  \_ [migration/1]
root          27       2  0 06:25 ?        00:00:00  \_ [ksoftirqd/1]
root          28       2  0 06:25 ?        00:00:00  \_ [kworker/1:0-events]
root          30       2  0 06:25 ?        00:00:00  \_ [cpuhp/2]
root          31       2  0 06:25 ?        00:00:00  \_ [idle_inject/2]
root          32       2  0 06:25 ?        00:00:01  \_ [migration/2]
root          33       2  0 06:25 ?        00:00:00  \_ [ksoftirqd/2]
root          35       2  0 06:25 ?        00:00:00  \_ [kworker/2:0H-kblockd]
```

**Команда_2:** 'pstree -p | head -n 50 | cat'

**Результаты(неполностью,просто для демонстрации):**
```
  systemd(1)-+-ModemManager(892)-+-{ModemManager}(924)
           |                   |-{ModemManager}(930)
           |                   `-{ModemManager}(934)
           |-NetworkManager(794)-+-{NetworkManager}(837)
           |                     |-{NetworkManager}(843)
           |                     `-{NetworkManager}(844)
           |-VBoxDRMClient(1282)-+-{VBoxDRMClient}(1291)
           |                     |-{VBoxDRMClient}(1292)
           |                     |-{VBoxDRMClient}(1295)
           |                     |-{VBoxDRMClient}(1305)
           |                     `-{VBoxDRMClient}(3225)
```

**Выводы:**
  'ps -ef --forest' предоставляет таблицу с детальной информацией о процессах, где иерархия показана через отступы. 
  'pstree -p' отображает чистое дерево процессов, что нагляднее показывает родительско-дочерние отношения, но содержит меньше технических данных.

### 3) Изучение /proc
**Цель:**
    Изучить виртуальную файловую систему /proc и научиться извлекать информацию о процессах через их файловые дескрипторы.

**Шаги/решения:**
    1. Узнать PID текущей оболочки: 'echo $$'
    2. Исследовать содержимое файлов в /proc/<pid>.
    3. Проанализировать полученную информацию

**PID текущей оболочки:**3427

**Команда_1:** 'cat /proc/3427/cmdline | tr '\0' ' '; echo'

**Результат:** 'bash'

**Команда_2:** 'head -n 20 /proc/3427/status'

**Результат:**
```
Name:	bash
Umask:	0002
State:	S (sleeping)
Tgid:	3427
Ngid:	0
Pid:	3427
PPid:	3419
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	4 24 27 30 46 100 114 1000 
NStgid:	3427
NSpid:	3427
NSpgid:	3427
NSsid:	3427
Kthread:	0
VmPeak:	    8668 kB
VmSize:	    8668 kB
VmLck:	       0 kB
```

**Команда_3:** 'ls -l /proc/3427/fd'

**Результат:**
```
lrwx------ 1 teres teres 64 сен 25 07:11 0 -> /dev/pts/0
lrwx------ 1 teres teres 64 сен 25 07:11 1 -> /dev/pts/0
lrwx------ 1 teres teres 64 сен 25 07:11 2 -> /dev/pts/0
lrwx------ 1 teres teres 64 сен 25 07:11 255 -> /dev/pts/0
```
    
**Выводы:**
   Первая команда позволяет узнать полную командную строку запуска процесса,
   вторая команда содержит информацию о текущем процессе, а третья - показывает все открытые процессом файлы и сокеты.


### 4) Анализ процессов (нагрузка CPU/память/IO)
  **Цель:** научиться анализировать живые процессы.

**Шаги/решения:**
    1. Использование команд для анализа процессов.
    2. Узнать TOP‑5 по CPU и памяти
    3. Анализ полученных данных

### 1.  Общая нагрузка системы
**Команда:** 'top -b -n 1 | head -n 20 | cat'
**Вывод:**
```
top - 12:21:49 up 37 min,  1 user,  load average: 0,01, 0,03, 0,07
Задачи: 246 total,   1 running, 245 sleeping,   0 stopped,   0 zombie
%Cpu(s):  6,4 us,  0,0 sy,  0,0 ni, 93,6 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st 
МиБ Mem :   4822,9 total,   1754,4 free,   1510,5 used,   1787,4 buff/cache     
МиБ Swap:   4096,0 total,   4096,0 free,      0,0 used.   3312,4 avail Mem 
```
**Краткий вывод:** Система почти не нагружена,используется 31% памяти

#### 2. TOP процессов по CPU
**Команда:** `ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 6 | cat`
**Вывод:**
```
    PID    PPID COMMAND         S %CPU %MEM     ELAPSED
   4862    3014 ps              R  100  0.0       00:00
   2203    1956 gnome-shell     R  1.6 10.1       37:28
   3144    2203 firefox         S  1.5  8.0       30:06
   4029    3394 Web Content     S  0.3  1.3       30:00
   1199       1 VBoxDRMClient   S  0.3  0.0       38:19
```
**Краткий вывод:**Основную CPU-нагрузку создают графическая оболочка GNOME Shell и браузер Firefox, при этом система в целом простаивает на 93%

#### 3. TOP процессов по памяти      
**Команда:** `ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 6 | cat`
**Вывод:**
```
    PID    PPID COMMAND         S %CPU %MEM   RSS
   2203    1956 gnome-shell     S  1.7 10.1 499040
   3144    2203 firefox         S  2.4  8.8 434812
   3430    3394 Privileged Cont S  0.1  2.8 139076
   2902    2203 mutter-x11-fram S  0.0  2.0 101928
   3648    3394 WebExtensions   S  0.0  1.9 96292
```
**Краткий вывод:**Наибольший объем памяти занимают компоненты графической среды GNOME (500 МБ) и браузера Firefox (430 МБ), что типично для десктоп-окружения.

### 4. Средние показатели за интервал (CPU/Memory/IO)
**Команда:** `pidstat -u -r -d 1 5 | cat`
**Вывод:**
```
Среднее:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Среднее:     0      1199    0,00    0,20    0,00    0,00    0,20     -  VBoxDRMClient
Среднее:  1000      2203    3,15    3,54    0,00    0,00    6,69     -  gnome-shell
Среднее:  1000      2603    0,00    0,20    0,00    0,00    0,20     -  gvfs-afc-volume
Среднее:  1000      3001    0,39    0,20    0,00    0,39    0,59     -  gnome-terminal-
Среднее:     0      3138    0,00    0,20    0,00    0,20    0,20     -  kworker/3:2-events
Среднее:  1000      3144    0,20    0,20    0,00    0,20    0,39     -  firefox
Среднее:  1000      3430    0,39    0,39    0,00    0,00    0,79     -  Privileged Cont
Среднее:  1000      4019    0,00    0,20    0,00    0,00    0,20     -  Web Content
Среднее:     0      4773    0,00    0,39    0,00    0,00    0,39     -  kworker/u19:4-events_unbound
Среднее:     0      4825    0,00    0,20    0,00    0,00    0,20     -  kworker/2:0-events
Среднее:  1000      4897    0,00    0,98    0,00    0,00    0,98     -  pidstat

Среднее:   UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
Среднее:  1000      2203    390,94     27,76 4878769  498812  10,10  gnome-shell
Среднее:  1000      3144      4,72      0,00 3130579  433220   8,77  firefox
Среднее:  1000      3430     51,77      0,00 2498352  139716   2,83  Privileged Cont
Среднее:  1000      4897      0,79      0,00    7908    4344   0,09  pidstat

Среднее:   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
Среднее:  1000      3144      0,00     18,11      0,00       0  firefox
```
**Краткий вывод:**Дисковая активность минимальна - только незначительная запись данных браузером Firefox (18 КБ/с).

#### Общий вывод:
  Система в виртуальной машине демонстрирует низкую нагрузку. Основное потребление ресурсов связано с графическим интерфейсом и пользовательскими приложениями, что соответствует ожиданиям для учебной среды

### 5) Мини‑утилита ptree
  **Цель:** написать утилиту, печатающую цепочку родителей от текущего процесса до PID 1 (init/systemd).

**Шаги/решения:**
    1. Написать необходимую программу.
    2. Собрать и запустить программы с помощью GCC: ```make ptree && ./ptree```
    
**Исходный код:**
     Исходный код утилиты представлен в src/ptree.c , а для его сборки используется Makefile
  
**Результат:** `Process chain: 3593 ← 3555 ← 3548 ← 1916 ← 1`
    
**Выводы:**
   Успешно создана утилита, которая отображает цепочку родительских процессов. 

## Ответы на вопросы
1. **Чем процесс отличается от программы?**  
   Программа — это исполняемый файл на диске (код + данные). Процесс — это экземпляр программы, загруженный в память и выполняющийся в системе.
 У процесса есть контекст выполнения: значения регистров, стек, открытые файлы и т.д.

2. **Что будет, если вызвать fork() без wait()?**  
   Родительский процесс завершится, не дождавшись потомков. Дочерние процессы станут "сиротами" и будут унаследованы процессом init (PID=1),
 который выполнит за них wait() и корректно уберет их из таблицы процессов.

3. **Как система хранит информацию о процессах?**  
   Информация о процессах хранится в виртуальной файловой системе /proc. Каждый процесс имеет свою директорию /proc/PID/ с файлами, содержащими информацию о состоянии,
 памяти, открытых файлах и т.д.

4. **Что делает exec() и зачем он нужен?**  
   Функция exec() заменяет текущий образ процесса новым исполняемым файлом. Она нужна для запуска новых программ в рамках существующего процесса.

5. **Почему в /proc нет «настоящих» файлов?**  
   /proc — виртуальная файловая система, которая существует только в памяти и предоставляет интерфейс для доступа к данным ядра и процессов в виде файлов.

6. **Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME?**  
   - %CPU: использование процессорного времени
   - %MEM: использование физической памяти
   - VIRT: общий объем виртуальной памяти
   - RES: резидентный размер (физическая память)
   - SHR: разделяемая память
   - TIME: общее процессорное время

7. **Почему сумма %CPU может быть больше 100%?**  
   На многоядерных системах каждое ядро дает 100%, поэтому если процесс использует несколько ядер, его %CPU может превышать 100%.

8. **Чем отличается мгновенное %CPU от load average?**  
   %CPU показывает мгновенную загрузку процессора, а load average — среднюю загрузку системы за 1, 5 и 15 минут.

9. **Чем IO-нагрузка отличается от CPU-нагрузки и как её увидеть?**  
   IO-нагрузка связана с операциями ввода-вывода, а CPU-нагрузка — с вычислениями. Для мониторинга IO используются: `pidstat -d`, `iotop`, `/proc/PID/io`.

10. **Что такое nice/приоритеты процессов и как они влияют на планирование?**  
   Nice value (-20 до 19) влияет на приоритет планирования. Более низкие значения дают higher priority (больше процессорного времени).

11. **Чем поток отличается от процесса и как увидеть потоки в ps/top?**  
   Потоки разделяют память и ресурсы процесса, а процессы изолированы. В `ps` потоки видны с ключом `-L`, в `top` — клавишей 'H'.

12. **Что такое зомби и сироты, как они возникают и куда «деваются»?**  
   Зомби — завершенные процессы, оставшиеся в таблице процессов до вызова wait() родителем. Сироты — процессы, чей родитель завершился; их усыновляет init.
 Зомби исчезают после вызова wait(), сироты завершаются нормально.

## Использование ИИ
- Проверка синтаксиса C-кода
- Объяснение работы системных вызовов (fork, wait)
- Для объяснения команд Linux
- Уточнение формата вывода команд Linux


