# Лабораторная 2 — Процессы и файловая система /proc
  Практика по процессам Linux. В этой работе разберается, что такое процесс, как они создаются, где смотреть информацию о них в /proc, и пишем простые программы.

## Цели
  Понять модель процессов Linux, принципы порождения и ожидания завершения, а также научиться извлекать информацию из /proc.

## Среда
  VM Ubuntu 24.04.3 на VirtualBox.

## Задания

### 1) Создание процессов
  **Цель**: родитель порождает двух дочерних; каждый дочерний печатает свой PID и PID родителя; родитель корректно ждёт всех дочерних.

**Шаги/решения:**
    1. Написать программу на С, в которой процесс-родитель вызывает порождение дважды.
    2. Собрать и запустить программы с помощью GCC: 'make fork_example && ./fork_example'

**Исходный код:**
  Исходный код программы представлен в src/fork_example.c , а для его сборки используется Makefile

**Результаты:***
```
  parent: PID=3585
  child_A: PID=3586, PPID=3585
  child_B: PID=3587, PPID=3585
```

**Выводы:**
  Родительский процесс успешно создает и ожидает завершения двух дочерних процессов.

### 2) Исследование дерева процессов
  **Цель:** изучить структуру дерева процессов в системе.

**Шаги/решения:**
    1. Просмотреть дерево процессов двумя способами.
    2. Найти свой процесс и родителей.
    3. Сравнить информацию, полученную обеими командами. 

**Команда_1:** 'ps -ef --forest | head -n 30 | cat'

**Результаты:**
```
  UID          PID    PPID  C STIME TTY          TIME CMD
root           2       0  0 06:25 ?        00:00:00 [kthreadd]
root           3       2  0 06:25 ?        00:00:00  \_ [pool_workqueue_release]
root           4       2  0 06:25 ?        00:00:00  \_ [kworker/R-rcu_gp]
root           5       2  0 06:25 ?        00:00:00  \_ [kworker/R-sync_wq]
root           6       2  0 06:25 ?        00:00:00  \_ [kworker/R-kvfree_rcu_reclaim]
root           7       2  0 06:25 ?        00:00:00  \_ [kworker/R-slub_flushwq]
root           8       2  0 06:25 ?        00:00:00  \_ [kworker/R-netns]
root          12       2  0 06:25 ?        00:00:00  \_ [kworker/u16:0-ipv6_addrconf]
root          13       2  0 06:25 ?        00:00:00  \_ [kworker/R-mm_percpu_wq]
root          14       2  0 06:25 ?        00:00:00  \_ [rcu_tasks_kthread]
root          15       2  0 06:25 ?        00:00:00  \_ [rcu_tasks_rude_kthread]
root          16       2  0 06:25 ?        00:00:00  \_ [rcu_tasks_trace_kthread]
root          17       2  0 06:25 ?        00:00:00  \_ [ksoftirqd/0]
root          18       2  0 06:25 ?        00:00:02  \_ [rcu_preempt]
root          19       2  0 06:25 ?        00:00:00  \_ [rcu_exp_par_gp_kthread_worker/0]
root          20       2  0 06:25 ?        00:00:00  \_ [rcu_exp_gp_kthread_worker]
root          21       2  0 06:25 ?        00:00:00  \_ [migration/0]
root          22       2  0 06:25 ?        00:00:00  \_ [idle_inject/0]
root          23       2  0 06:25 ?        00:00:00  \_ [cpuhp/0]
root          24       2  0 06:25 ?        00:00:00  \_ [cpuhp/1]
root          25       2  0 06:25 ?        00:00:00  \_ [idle_inject/1]
root          26       2  0 06:25 ?        00:00:01  \_ [migration/1]
root          27       2  0 06:25 ?        00:00:00  \_ [ksoftirqd/1]
root          28       2  0 06:25 ?        00:00:00  \_ [kworker/1:0-events]
root          30       2  0 06:25 ?        00:00:00  \_ [cpuhp/2]
root          31       2  0 06:25 ?        00:00:00  \_ [idle_inject/2]
root          32       2  0 06:25 ?        00:00:01  \_ [migration/2]
root          33       2  0 06:25 ?        00:00:00  \_ [ksoftirqd/2]
root          35       2  0 06:25 ?        00:00:00  \_ [kworker/2:0H-kblockd]
```

**Команда_2:** 'pstree -p | head -n 50 | cat'

**Результаты(неполностью,просто для демонстрации):**
```
  systemd(1)-+-ModemManager(892)-+-{ModemManager}(924)
           |                   |-{ModemManager}(930)
           |                   `-{ModemManager}(934)
           |-NetworkManager(794)-+-{NetworkManager}(837)
           |                     |-{NetworkManager}(843)
           |                     `-{NetworkManager}(844)
           |-VBoxDRMClient(1282)-+-{VBoxDRMClient}(1291)
           |                     |-{VBoxDRMClient}(1292)
           |                     |-{VBoxDRMClient}(1295)
           |                     |-{VBoxDRMClient}(1305)
           |                     `-{VBoxDRMClient}(3225)
```

**Выводы:**
  'ps -ef --forest' предоставляет таблицу с детальной информацией о процессах, где иерархия показана через отступы. 
  'pstree -p' отображает чистое дерево процессов, что нагляднее показывает родительско-дочерние отношения, но содержит меньше технических данных.

### 3) Изучение /proc
**Цель:**
    Изучить виртуальную файловую систему /proc и научиться извлекать информацию о процессах через их файловые дескрипторы.

**Шаги/решения:**
    1. Узнать PID текущей оболочки: 'echo $$'
    2. Исследовать содержимое файлов в /proc/<pid>.
    3. Проанализировать полученную информацию

**PID текущей оболочки:**3427

**Команда_1:** 'cat /proc/3427/cmdline | tr '\0' ' '; echo'

**Результат:** 'bash'

**Команда_2:** 'head -n 20 /proc/3427/status'

**Результат:**
```
Name:	bash
Umask:	0002
State:	S (sleeping)
Tgid:	3427
Ngid:	0
Pid:	3427
PPid:	3419
TracerPid:	0
Uid:	1000	1000	1000	1000
Gid:	1000	1000	1000	1000
FDSize:	256
Groups:	4 24 27 30 46 100 114 1000 
NStgid:	3427
NSpid:	3427
NSpgid:	3427
NSsid:	3427
Kthread:	0
VmPeak:	    8668 kB
VmSize:	    8668 kB
VmLck:	       0 kB
```

**Команда_3:** 'ls -l /proc/3427/fd'

**Результат:**
```
lrwx------ 1 teres teres 64 сен 25 07:11 0 -> /dev/pts/0
lrwx------ 1 teres teres 64 сен 25 07:11 1 -> /dev/pts/0
lrwx------ 1 teres teres 64 сен 25 07:11 2 -> /dev/pts/0
lrwx------ 1 teres teres 64 сен 25 07:11 255 -> /dev/pts/0
```
    
**Выводы:**
   Первая команда позволяет узнать полную командную строку запуска процесса,
   вторая команда содержит информацию о текущем процессе, а третья - показывает все открытые процессом файлы и сокеты.


### 4) Анализ процессов (нагрузка CPU/память/IO)
  **Цель:** научиться анализировать живые процессы.

**Шаги/решения:**
### 1.  Общая нагрузка системы
**Команда:** 'top -b -n 1 | head -n 20 | cat'
**Вывод:**
```

```

#### 2. TOP процессов по CPU
**Команда:** `ps -eo pid,ppid,comm,state,%cpu,%mem,etime --sort=-%cpu | head -n 15 | cat`
**Вывод:**
```

```

#### 3. TOP процессов по памяти      
**Команда:** `ps -eo pid,ppid,comm,state,%cpu,%mem,rss --sort=-%mem | head -n 15 | cat`
**Вывод:**
```

```

### 4. Средние показатели за интервал (CPU/Memory/IO)
**Команда:** `pidstat -u -r -d 1 5 | cat`
**Вывод:**
```

```

#### Общий вывод для 1-4
  

### 5) Мини‑утилита ptree
  **Цель:** написать утилиту, печатающую цепочку родителей от текущего процесса до PID 1 (init/systemd).

**Шаги/решения:**
    1. Написать необходимую программу.
    2. Собрать и запустить программы с помощью GCC: ```make ptree && ./ptree```
    
**Исходный код:**
     Исходный код утилиты представлен в src/ptree.c , а для его сборки используется Makefile
  
**Результат:** `Process chain: 3593 ← 3555 ← 3548 ← 1916 ← 1`
    
**Выводы:**
   Успешно создана утилита, которая отображает цепочку родительских процессов. 

## Ответы на вопросы
1. **Чем процесс отличается от программы?**  
   Программа — это исполняемый файл на диске (код + данные). Процесс — это экземпляр программы, загруженный в память и выполняющийся в системе.
 У процесса есть контекст выполнения: значения регистров, стек, открытые файлы и т.д.

2. **Что будет, если вызвать fork() без wait()?**  
   Родительский процесс завершится, не дождавшись потомков. Дочерние процессы станут "сиротами" и будут унаследованы процессом init (PID=1),
 который выполнит за них wait() и корректно уберет их из таблицы процессов.

3. **Как система хранит информацию о процессах?**  
   Информация о процессах хранится в виртуальной файловой системе /proc. Каждый процесс имеет свою директорию /proc/PID/ с файлами, содержащими информацию о состоянии,
 памяти, открытых файлах и т.д.

4. **Что делает exec() и зачем он нужен?**  
   Функция exec() заменяет текущий образ процесса новым исполняемым файлом. Она нужна для запуска новых программ в рамках существующего процесса.

5. **Почему в /proc нет «настоящих» файлов?**  
   /proc — виртуальная файловая система, которая существует только в памяти и предоставляет интерфейс для доступа к данным ядра и процессов в виде файлов.

6. **Как интерпретировать поля top: %CPU, %MEM, VIRT, RES, SHR, TIME?**  
   - %CPU: использование процессорного времени
   - %MEM: использование физической памяти
   - VIRT: общий объем виртуальной памяти
   - RES: резидентный размер (физическая память)
   - SHR: разделяемая память
   - TIME: общее процессорное время

7. **Почему сумма %CPU может быть больше 100%?**  
   На многоядерных системах каждое ядро дает 100%, поэтому если процесс использует несколько ядер, его %CPU может превышать 100%.

8. **Чем отличается мгновенное %CPU от load average?**  
   %CPU показывает мгновенную загрузку процессора, а load average — среднюю загрузку системы за 1, 5 и 15 минут.

9. **Чем IO-нагрузка отличается от CPU-нагрузки и как её увидеть?**  
   IO-нагрузка связана с операциями ввода-вывода, а CPU-нагрузка — с вычислениями. Для мониторинга IO используются: `pidstat -d`, `iotop`, `/proc/PID/io`.

10. **Что такое nice/приоритеты процессов и как они влияют на планирование?**  
   Nice value (-20 до 19) влияет на приоритет планирования. Более низкие значения дают higher priority (больше процессорного времени).

11. **Чем поток отличается от процесса и как увидеть потоки в ps/top?**  
   Потоки разделяют память и ресурсы процесса, а процессы изолированы. В `ps` потоки видны с ключом `-L`, в `top` — клавишей 'H'.

12. **Что такое зомби и сироты, как они возникают и куда «деваются»?**  
   Зомби — завершенные процессы, оставшиеся в таблице процессов до вызова wait() родителем. Сироты — процессы, чей родитель завершился; их усыновляет init.
 Зомби исчезают после вызова wait(), сироты завершаются нормально.

## Использование ИИ
- Проверка синтаксиса C-кода
- Объяснение работы системных вызовов (fork, wait)
- Для объяснения команд Linux
- Уточнение формата вывода команд Linux

